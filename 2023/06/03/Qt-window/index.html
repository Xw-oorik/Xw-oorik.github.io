


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  QTimer定时器,窗口界面操作 |    Oorik.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/emoji-18/61/21-64.png" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Oorik.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="sort">
             CATEGORIES
             <div class="categories-outer " id="sort-div">
               <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp%E8%BF%9B%E9%98%B6/">Cpp进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%BF%9B%E9%98%B6/">C进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt%E5%AD%A6%E4%B9%A0/">Qt学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a></li></ul>
             </div>
          </li>
        
        
        <a href="/search">
          <li class="menu-li  animate__animated  animate__fadeInUp">
            <i class="ri-search-line"></i>
          </li>
        </a>
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Oorik.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
    <a href="/search">  
      <div class="mobile-menu-child  animate__animated  animate__fadeInUp">
        <i class="ri-search-line"></i>
      </div>
    </a>
    
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">QTimer定时器,窗口界面操作</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Jun 03 2023</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h2 id="QTimer定时器，窗口界面操作"><a href="#QTimer定时器，窗口界面操作" class="headerlink" title="QTimer定时器，窗口界面操作"></a>QTimer定时器，窗口界面操作</h2><p><strong>本系列为跟随大丙老师博客学习笔记</strong></p>
<h3 id="QTimer-定时器"><a href="#QTimer-定时器" class="headerlink" title="QTimer 定时器"></a>QTimer 定时器</h3><blockquote>
<pre><code class="cpp">// 构造函数
// 如果指定了父对象, 创建的堆内存可以自动析构
QTimer::QTimer(QObject *parent = nullptr);

// 设置定时器时间间隔为 msec 毫秒
// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发
void QTimer::setInterval(int msec);
// 获取定时器的时间间隔, 返回值单位: 毫秒
int QTimer::interval() const;

// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔
[slot] void QTimer::start();
// 启动或重新启动定时器，超时间隔为msec毫秒。
[slot] void QTimer::start(int msec);
// 停止定时器。
[slot] void QTimer::stop();

// 设置定时器精度
/*
参数: 
    - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级
    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度
    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右
*/
void QTimer::setTimerType(Qt::TimerType atype);
Qt::TimerType QTimer::timerType() const;	// 获取当前定时器的精度

// 如果定时器正在运行，返回true; 否则返回false。
bool QTimer::isActive() const;

// 判断定时器是否只触发一次
bool QTimer::isSingleShot() const;
// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false
void QTimer::setSingleShot(bool singleShot);
</code></pre>
</blockquote>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605205140768.png" >
        </sapn>
      </p>
<p>mianwindow.cpp</p>
<pre><code class="cpp">#include&lt;QTime&gt;
#include&lt;QTimer&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);
    //创建定时器对象
    QTimer *tt=new QTimer(this);
    //设置精度
    tt-&gt;setTimerType(Qt::PreciseTimer);
    //按钮点击事件，周期性获得当前时间
    connect(ui-&gt;startBtn,&amp;QPushButton::clicked,this,[=]()
    &#123;
        //启动定时器
        if(tt-&gt;isActive())//如果是启动的状态
        &#123;
            tt-&gt;stop();  //关闭 ，设为开始
            ui-&gt;startBtn-&gt;setText(&quot;开始&quot;);
        &#125;
        else&#123;
            ui-&gt;startBtn-&gt;setText(&quot;关闭&quot;);
            tt-&gt;start(1000);//1s
        &#125;
    &#125;);
    connect(tt,&amp;QTimer::timeout,this,[=]()
    &#123;
       //获得当前时间
        QTime tm=QTime::currentTime();
        QString str=tm.toString(&quot;hh:mm::ss.zzz&quot;);
        ui-&gt;labshow-&gt;setText(str);
    &#125;);
&#125;
</code></pre>
<h3 id="窗口练习"><a href="#窗口练习" class="headerlink" title="窗口练习"></a>窗口练习</h3><pre><code class="cpp">    setMaximumSize(600,600);
    setMinimumSize(300,300);
//没有设置固定大小，这样的话就能随意放缩
    setWindowTitle(&quot;hello hexo&quot;);//标题
    setWindowIcon(QIcon(&quot;F:\\PotBa\\public\\favicon2.ico&quot;));//图标
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605213102594.png" >
        </sapn>
      </p>
<p>ui空间快速写槽函数</p>
<p>鼠标右键点击 转到槽</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605213514978.png" >
        </sapn>
      </p>
<p>选择要发出的信号，确定，他会自动给你生成一个槽函数</p>
<pre><code class="cpp">void MainWindow::on_yd_clicked()
&#123;
    
&#125;
</code></pre>
<p><strong>实现一个功能</strong></p>
<p>我们点击移动窗口，窗口根据我们设定的值偏移，获取当前位置信息打印，修改窗口位置和尺寸信息按钮，点击随机生成新位置，窗口自动移动到新位置</p>
<p>注意这里我们把主窗口设置大小的函数注释掉了，这样才能让他整个屏幕跑，不去限制他的大小和位置</p>
<pre><code class="cpp">void MainWindow::on_yd_clicked()
&#123;
    //获取当前窗口位置
    QRect rect=this-&gt;frameGeometry();
    //移动 从当前窗口位置左上角 向右下移动
    move(rect.topLeft()+QPoint(rand()%50,rand()%30));

&#125;

void MainWindow::on_yd1_clicked()
&#123;
    QRect rect=this-&gt;frameGeometry();
    qDebug()&lt;&lt;&quot;左上角：&quot;&lt;&lt;rect.topLeft()
           &lt;&lt;&quot;右上角：&quot;&lt;&lt;rect.topRight()
             &lt;&lt;&quot;左下角：&quot;&lt;&lt;rect.bottomLeft()
               &lt;&lt;&quot;右下角：&quot;&lt;&lt;rect.bottomRight()
                 &lt;&lt;&quot;宽度：&quot;&lt;&lt;rect.width()
                   &lt;&lt;&quot;高度：&quot;&lt;&lt;rect.height();

&#125;

void MainWindow::on_yd2_clicked()
&#123;
    int x=100+rand()%500;
    int y=100+rand()%500;
    int width=this-&gt;width()+50;
    int height=this-&gt;height()+30;
    setGeometry(x,y,width,height);
&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605215200211.png" >
        </sapn>
      </p>
<pre><code class="c">我移动了几次
    
左上角： QPoint(939,238) 右上角： QPoint(1890,238) 左下角： QPoint(939,966) 右下角： QPoint(1890,966) 宽度： 952 高度： 729
    
左上角： QPoint(112,283) 右上角： QPoint(1113,283) 左下角： QPoint(112,1041) 右下角： QPoint(1113,1041) 宽度： 1002 高度： 759
</code></pre>
<p>下面添加个功能，点击按钮重新设置一下窗口的标题和图标</p>
<pre><code class="cpp">void MainWindow::on_rebuild_clicked()  //重新设置标题和图标
&#123;
    this-&gt;setWindowIcon(QIcon(&quot;F:\\PotBa\\public\\favicon1.ico&quot;));
    this-&gt;setWindowTitle(&quot;新标题&quot;);
&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605220043779.png" >
        </sapn>
      </p>
<p>在mainwindow构造函数添加个connect响应的打印信息，当按钮被按下，信号发出，槽函数接收到信号做替换标题和图标的处理，当图标&#x2F;标题被修改了，发出俩信号windowTitleChanged和windowIconChanged，我们去写个匿名的槽函数去接收这俩信号然后做个打印</p>
<pre><code class="cpp">
        connect(this,&amp;MainWindow::windowTitleChanged,this,[=](const QString &amp;title )
    &#123;
        qDebug()&lt;&lt;&quot;新的标题是:&quot;&lt;&lt;title;
    &#125;);
    connect(this,&amp;MainWindow::windowIconChanged,this,[=](const QIcon &amp;icon )
    &#123;
        qDebug()&lt;&lt;&quot;新的图标是:&quot;&lt;&lt;icon;
    &#125;);
</code></pre>
<p><strong>添加新功能，我们增加鼠标右键菜单。默认我们对窗口右键是没反应的</strong></p>
<pre><code class="cpp">    //设置右键菜单策略
    setContextMenuPolicy(Qt::CustomContextMenu);
    connect(this,&amp;MainWindow::customContextMenuRequested,this,[=](const QPoint&amp; p)&#123;
        //创建一个空菜单
        QMenu menu;
        menu.addAction(&quot;点餐&quot;);
        menu.addAction(&quot;住宿&quot;);
        menu.addAction(&quot;游玩&quot;);
        menu.exec(QCursor::pos());//鼠标右键点击的坐标位置，相对于系统屏幕的，而不是当前窗口
        
    &#125;);
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605222153208.png" >
        </sapn>
      </p>
<p>上面的一些操作都是QWidget这个父类的，虽然用的mainwindow，但是是mainwindow继承QWidget他这个类的，所以操作api也是能用的，所以上面的示例api都是QWidget本身的</p>
<p>对于三个窗口关系，可以去看我Qt第一讲 -&gt;移步主页csdn链接</p>
<p>下面说QDialog一些操作，他特有操作对于QWidget肯定就用不了了，父子继承明白吧</p>
<h3 id="QDialog对话框"><a href="#QDialog对话框" class="headerlink" title="QDialog对话框"></a>QDialog对话框</h3><p>QDialog类里面上面那些操作也是能用的</p>
<p>下面对于他特有的api去操作，上面的案例</p>
<p>dialog里面的accept，reject，done</p>
<pre><code class="cpp">// 模态显示窗口
[virtual slot] int QDialog::exec();
// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted
[virtual slot] void QDialog::accept();
// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected
[virtual slot] void QDialog::reject();
// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;
// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。
[virtual slot] void QDialog::done(int r);

发射信号
[signal] void QDialog::accepted();
[signal] void QDialog::rejected();
[signal] void QDialog::finished(int result);
</code></pre>
<p>创建一个dialog类，创建三个按钮</p>
<p>在dialog.cpp创建槽函数</p>
<pre><code class="cpp">void MyDialog::on_ac_clicked()
&#123;
    //结束模态对话框的阻塞，隐藏
    this-&gt;accept();
&#125;

void MyDialog::on_re_clicked()
&#123;
    this-&gt;reject();
&#125;

void MyDialog::on_do_2_clicked()
&#123;
    this-&gt;done(10); //自定义的返回值
&#125;
</code></pre>
<p>在mainwindow里面加一个按钮显示调用 模态的dialog对话框</p>
<pre><code class="cpp">void MainWindow::on_module_clicked()
&#123;
    MyDialog dig;
    int ret=dig.exec();
    if(ret==QDialog::Accepted)&#123; //返回1
        qDebug()&lt;&lt;&quot;accept clicked&quot;;
    &#125;
    else if(ret==QDialog::Rejected)&#123; //返回0
        qDebug()&lt;&lt;&quot;reject clicked&quot;;
    &#125;
    else&#123;
        qDebug()&lt;&lt;&quot;done clicked&quot;;
    &#125;
&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605224505474.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605224527353.png" >
        </sapn>
      </p>
<p>对于dialog的模态非模态，模态就是当前窗口点开了，就不能操作别的窗口了，点击别的地方会发出那种声响你懂吧，非模态就是随便操作咯</p>
<p>我们加个打印去接收一下这三个信号，看看返回值</p>
<p>修改一下槽函数，看下打印：</p>
<pre><code class="cpp">void MainWindow::on_module_clicked()
&#123;
    MyDialog dig;
    connect(&amp;dig,&amp;MyDialog::finished,this,[=](int res)&#123;
        qDebug()&lt;&lt;&quot;finished: &quot;&lt;&lt;res;
    &#125;);
    connect(&amp;dig,&amp;MyDialog::accepted,this,[=]()&#123;
        qDebug()&lt;&lt;&quot;accept 发射--: &quot;;
    &#125;);
    connect(&amp;dig,&amp;MyDialog::rejected,this,[=]()&#123;
        qDebug()&lt;&lt;&quot;rejected 发射--:&quot; ;
    &#125;);
    int ret=dig.exec();
    if(ret==QDialog::Accepted)&#123; //返回1
        qDebug()&lt;&lt;&quot;accept clicked&quot;;
    &#125;
    else if(ret==QDialog::Rejected)&#123; //返回0
        qDebug()&lt;&lt;&quot;reject clicked&quot;;
    &#125;
    else&#123;
        qDebug()&lt;&lt;&quot;done clicked&quot;;
    &#125;
&#125;
</code></pre>
<p>我三个按钮都点了一下，效果如下，accept果然返回的是1，reject返回0，done返回我们自定义</p>
<p>finished就是去对应发出三个的信号，且能接收参数的</p>
<p>而accepted和rejected只是对应accept和reject的，且不带参数</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230605230055771.png" >
        </sapn>
      </p>
<h3 id="看QDialog子类"><a href="#看QDialog子类" class="headerlink" title="看QDialog子类"></a>看QDialog子类</h3><h4 id="QMessageBox-消息提示框"><a href="#QMessageBox-消息提示框" class="headerlink" title="QMessageBox 消息提示框"></a>QMessageBox 消息提示框</h4><p>在mainwindow加一个控件，实现对应槽函数，应用QMessageBox 类的api，就有如下效果</p>
<pre><code class="cpp">void MainWindow::on_msgbox_clicked()
&#123;
    QMessageBox::about(this,&quot;about&quot;,&quot;这是一个简单的测试消息提示框！&quot;);
    QMessageBox::critical(this,&quot;critical&quot;,&quot;这是一个测试错误对话框!&quot;);
    int ret=QMessageBox::question(this,&quot;question&quot;,&quot;你要保存修改的内容吗？？&quot;,
                                  QMessageBox::Save|QMessageBox::Cancel,
                                  QMessageBox::Cancel);
    if(ret==QMessageBox::Save)
    &#123;
        QMessageBox::information(this,&quot;information&quot;,&quot;恭喜保存成功！&quot;);
    &#125;
    else if(ret==QMessageBox::Cancel)
    &#123;
        QMessageBox::warning(this, &quot;warning&quot;, &quot;你放弃了保存, ┭┮﹏┭┮ !!!&quot;);
    &#125;

&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606000430414.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606000436448.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606000449122.png" >
        </sapn>
      </p>
<h4 id="QFileDialog"><a href="#QFileDialog" class="headerlink" title="QFileDialog"></a>QFileDialog</h4><p>QFileDialog 对话框类是 QDialog 类的子类，<strong>通过这个类可以选择要打开 &#x2F; 保存的文件或者目录</strong>。关于这个类我们只需要掌握一些静态方法的使用就可以了。</p>
<p>添加新功能： &#x2F;&#x2F;打开多个文件  &#x2F;&#x2F;打开保存文件对话框</p>
<p>当然这里实现保存文件，肯定是没有未保存的，这里只是做gui的演示，具体文件操作就需要open，write那些c++&#x2F;c的api去操作文件了，就是后端逻辑</p>
<pre><code class="cpp">void MainWindow::on_mulu_clicked()
&#123;
#if 0
    QString arg(&quot;Text files(*.txt *.md&quot;);//指定以这个格式过滤,意思只显示这两种类型文件
    //打开多个文件，得到文件的绝对路径
    QStringList filenames=QFileDialog::getOpenFileNames(
                this,&quot;open files&quot;,&quot;F:\\&quot;,
                &quot;Images(*.png *.jpg);;Text files(*.txt *.md)&quot;,
                &amp;arg);  //指定了多个过滤器，默认是第一个。我这里手动指定是.txt *.md的
    QString names;
    for(auto x:filenames)
    &#123;
        names+=x+&quot;%%%&quot;;
    &#125;
    //以QMessageBox提示框显示
     QMessageBox::information(this,&quot;打开文件(s)&quot;,&quot;您选择的文件是: &quot;+names);

#else
    QString filename=QFileDialog::getSaveFileName(this,&quot;保存文件&quot;,&quot;F:\\PotBa&quot;);
    QMessageBox::information(this,&quot;保存文件成功！&quot;,&quot;保存的文件是:&quot;+filename);
#endif

&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606202621889.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606202706824.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606202714382.png" >
        </sapn>
      </p>
<p>并没有替换成功，只是界面展示这样</p>
<h4 id="QFontDialog"><a href="#QFontDialog" class="headerlink" title="QFontDialog"></a>QFontDialog</h4><p>根据这个对话框类，拿到一个设置字体的对话框（字体，大小，等等）</p>
<p>我们只需要调用这个类的静态成员函数就可以得到想要的窗口了。</p>
<p><strong>关于设置字体属性的我们需要借助QFont这个类</strong></p>
<pre><code class="cpp">// 构造函数
  QFont::QFont();
  /*
  参数:
    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看
    - pointSize: 字体的字号
    - weight: 字体的粗细, 有效范围为 0 ~ 99
    - italic: 字体是否倾斜显示, 默认不倾斜
  */
  QFont::QFont(const QString &amp;family, int pointSize = -1, int weight = -1, bool italic = false);
  
  // 设置字体
  void QFont::setFamily(const QString &amp;family);
  // 根据字号设置字体大小
  void QFont::setPointSize(int pointSize);
  // 根据像素设置字体大小
  void QFont::setPixelSize(int pixelSize);
  // 设置字体的粗细程度, 有效范围: 0 ~ 99
  void QFont::setWeight(int weight);
  // 设置字体是否加粗显示
  void QFont::setBold(bool enable);
  // 设置字体是否要倾斜显示
  void QFont::setItalic(bool enable);
  
  // 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)
  QString QFont::family() const;
  bool QFont::italic() const;
  int QFont::pixelSize() const;
  int QFont::pointSize() const;
  bool QFont::bold() const;
  int QFont::weight() const;


/*
参数:
  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址
  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化
  - parent: 字体对话框窗口的父对象
  - title: 字体对话框的窗口标题
  - options: 字体对话框选项, 使用默认属性即可, 一般不设置
*/
  [static] QFont QFontDialog::getFont(
        bool *ok, const QFont &amp;initial, 
        QWidget *parent = nullptr, const QString &amp;title = QString(), 
        QFontDialog::FontDialogOptions options = FontDialogOptions());
  
  [static] QFont QFontDialog::getFont(bool *ok, QWidget *parent = nullptr);


// QWidget 类
// 得到当前窗口使用的字体
const QWidget::QFont&amp; font() const;
// 给当前窗口设置字体, 只对当前窗口类生效
void QWidget::setFont(const QFont &amp;);

// QApplication 类
// 得到当前应用程序对象使用的字体
[static] QFont QApplication::font();
// 给当前应用程序对象设置字体, 作用于当前应用程序的所有窗口
[static] void QApplication::setFont(const QFont &amp;font, const char *className = nullptr);
</code></pre>
<p><strong>添加新功能：</strong></p>
<p>我们点击设置字体，选择完成后，更改下方标签hello word！！！字体，并且改变所有窗口的字体设置</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606204515765.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606205300941.png" >
        </sapn>
      </p>
<p>设置，标签测试+整个窗口字体</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606205437956.png" >
        </sapn>
      </p>
<pre><code class="cpp">void MainWindow::on_font_clicked()
&#123;
    bool ok;
    bool is=true;                                                 //默认不倾斜，这里设置倾斜 true
    QFont font=QFontDialog::getFont(&amp;ok,QFont(&quot;微软雅黑&quot;,12,QFont::Bold,is),this,&quot;选择字体&quot;);
    qDebug()&lt;&lt;&quot; ok is : &quot;&lt;&lt;ok;
        //作用到全部窗口 和label标签
    ui-&gt;fontlabel-&gt;setFont(font);
    QApplication::setFont(font, nullptr);//默认
&#125;
</code></pre>
<h4 id="QColorDialog"><a href="#QColorDialog" class="headerlink" title="QColorDialog"></a>QColorDialog</h4><p>颜色对话框类，配置颜色用 QColor</p>
<p>使用和设置字体基本大差不差</p>
<pre><code class="cpp">void MainWindow::on_colorbt_clicked()
&#123;
    QColor col=QColorDialog::getColor();
    //绘图操作
    QBrush brush(col);
    QRect rect(0,0,ui-&gt;colorshow-&gt;width(),ui-&gt;colorshow-&gt;height());
    QPixmap pix(rect.width(), rect.height());
    QPainter p(&amp;pix);
    p.fillRect(rect, brush);
    ui-&gt;colorshow-&gt;setPixmap(pix);
    QString text = QString(&quot;red: %1, green: %2, blue: %3, 透明度: %4&quot;)
               .arg(col.red()).arg(col.green()).arg(col.blue()).arg(col.alpha());
    ui-&gt;colorpt-&gt;setText(text);
&#125;
</code></pre>
<p><strong>代码解释如下:</strong></p>
<p>这段代码是一个槽函数，当用户点击名为<code>colorbt</code>的按钮时，就会执行这个函数。这个函数的作用是打开一个颜色选择对话框，然后根据用户选择的颜色在名为<code>colorshow</code>的窗口部件上填充颜色，并在名为<code>colorpt</code>的标签上显示选择的颜色的RGB值和透明度。</p>
<p>首先，<code>QColorDialog::getColor()</code>函数用于打开一个颜色选择对话框，让用户选择颜色。这个函数会返回一个<code>QColor</code>对象，表示用户选择的颜色。</p>
<p>然后，根据用户选择的颜色创建一个<code>QBrush</code>对象<code>brush</code>，并创建一个与<code>colorshow</code>窗口部件大小相同的矩形区域<code>rect</code>，用于在后续的绘图操作中指定绘图区域。接着，创建一个<code>QPixmap</code>对象<code>pix</code>，表示一个像素图，大小与<code>rect</code>相同。</p>
<p>使用<code>QPainter</code>对象<code>p</code>在<code>pix</code>上进行绘图操作，使用<code>fillRect</code>函数在<code>rect</code>矩形区域内填充颜色，颜色由<code>brush</code>指定。最后，使用<code>ui-&gt;colorshow-&gt;setPixmap(pix)</code>将绘制好的<code>pix</code>像素图设置为<code>colorshow</code>窗口部件的显示内容，从而实现在<code>colorshow</code>窗口部件上填充用户选择的颜色的效果。</p>
<p>最后，使用<code>QString</code>类的<code>arg</code>函数将颜色的RGB值和透明度格式化成一个字符串，并将其设置为<code>colorpt</code>标签的文本内容，从而在<code>colorpt</code>标签上显示用户选择的颜色的RGB值和透明度。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606211930864.png" >
        </sapn>
      </p>
<p><strong>点击设置颜色</strong></p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606211950340.png" >
        </sapn>
      </p>
<p><strong>设置完成</strong></p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606212021843.png" >
        </sapn>
      </p>
<h4 id="QInputDialog"><a href="#QInputDialog" class="headerlink" title="QInputDialog"></a>QInputDialog</h4><p>这是一个输入对话框窗口</p>
<pre><code class="cpp">// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - value: 对话框窗口中显示的浮点值, 默认为 0
  - min: 对话框窗口支持显示的最小数值
  - max: 对话框窗口支持显示的最大数值
  - decimals: 浮点数的精度, 默认保留小数点以后1位
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
*/
[static] double QInputDialog::getDouble(
            QWidget *parent, const QString &amp;title, 
            const QString &amp;label, double value = 0, 
            double min = -2147483647, double max = 2147483647, 
            int decimals = 1, bool *ok = nullptr, 
            Qt::WindowFlags flags = Qt::WindowFlags());

// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - value: 对话框窗口中显示的整形值, 默认为 0
  - min: 对话框窗口支持显示的最小数值
  - max: 对话框窗口支持显示的最大数值
  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
*/
[static] int QInputDialog::getInt(
            QWidget *parent, const QString &amp;title, 
            const QString &amp;label, int value = 0, 
            int min = -2147483647, int max = 2147483647, 
            int step = 1, bool *ok = nullptr, 
            Qt::WindowFlags flags = Qt::WindowFlags());

// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项
  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)
  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串
    - 如果有特殊需求, 可以参数帮助文档进行相关设置
*/
[static] QString QInputDialog::getItem(
            QWidget *parent, const QString &amp;title, 
            const QString &amp;label, const QStringList &amp;items, 
            int current = 0, bool editable = true, bool *ok = nullptr, 
            Qt::WindowFlags flags = Qt::WindowFlags(), 
            Qt::InputMethodHints inputMethodHints = Qt::ImhNone);

// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串
    - 如果有特殊需求, 可以参数帮助文档进行相关设置
*/
[static] QString QInputDialog::getMultiLineText(
            QWidget *parent, const QString &amp;title, const QString &amp;label, 
            const QString &amp;text = QString(), bool *ok = nullptr, 
            Qt::WindowFlags flags = Qt::WindowFlags(), 
            Qt::InputMethodHints inputMethodHints = Qt::ImhNone);

// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息
/*
参数:
  - parent: 对话框窗口的父窗口 
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值
    - QLineEdit::Normal: 显示输入的字符。这是默认值
    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。
    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。
    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。
  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串
     - 如果有特殊需求, 可以参数帮助文档进行相关设置
*/
[static] QString QInputDialog::getText(
            QWidget *parent, const QString &amp;title, const QString &amp;label,
            QLineEdit::EchoMode mode = QLineEdit::Normal, 
            const QString &amp;text = QString(), bool *ok = nullptr, 
            Qt::WindowFlags flags = Qt::WindowFlags(), 
            Qt::InputMethodHints inputMethodHints = Qt::ImhNone);
</code></pre>
<p><strong>添加新功能：滚动设置，写一个下拉选择框，设置密码（一行文本编辑），多行文本编辑</strong></p>
<p>也都是调用静态函数，如下案例代码：</p>
<pre><code class="cpp">#define LINE
void MainWindow::on_chat_clicked()
&#123;
#ifdef INT
    int res=QInputDialog::getInt(this,&quot;设置年龄&quot;,&quot;年龄:&quot;,0,0,100,1);
    QMessageBox::information(this,&quot;成功！&quot;,&quot;年龄设置为:&quot;+QString::number(res));

#endif

#ifdef ITEM
    QStringList  list;
    list&lt;&lt;&quot;麻婆豆腐&quot;&lt;&lt;&quot;红烧肉&quot;&lt;&lt;&quot;锅包肉&quot;;
    QString str=QInputDialog::getItem(this,&quot;菜单&quot;,&quot;选择菜品:&quot;,list,1,true);
    QMessageBox::information(this,&quot;点菜成功！&quot;,&quot;点的菜为:&quot;+str);
#endif

#ifdef TEXT                                              //默认设置是123456密码
    QString text = QInputDialog::getText(this, &quot;密码&quot;, &quot;请输入新的密码&quot;, QLineEdit::Password, &quot;123456&quot;);
    QMessageBox::information(this, &quot;密码&quot;, &quot;您设置的密码是: &quot; + text);
#endif

#ifdef LINE
    QString ss=QInputDialog::getMultiLineText(this,&quot;漂流瓶&quot;,&quot;写给30年后的自己&quot;,&quot;你好,30年后的xxx:&quot;);
    QMessageBox::information(this, &quot;漂流瓶&quot;, &quot;您对30年后的自己写的话是: &quot; + ss);
#endif
&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606214646189.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606215321602.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606215615293.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606220104563.png" >
        </sapn>
      </p>
<h4 id="QProgressDialog"><a href="#QProgressDialog" class="headerlink" title="QProgressDialog"></a>QProgressDialog</h4><p>进度条对话框窗口类</p>
<p>新添功能：实现一个模拟下载的进度框，为模态的窗口，当取消下载后，当前窗口关闭，对象析构，而不需要等着父对象析构他再析构</p>
<pre><code class="cpp">void MainWindow::on_download_clicked()
&#123;
        //创建进度条对话框窗口对象
        QProgressDialog *pro=new QProgressDialog(&quot;正在下载..&quot;,&quot;取消下载&quot;,0,100,this);
        //初始化显示进度条窗口
        pro-&gt;setWindowTitle(&quot;请稍等..&quot;);
        pro-&gt;setWindowModality(Qt::WindowModal);//模态
        pro-&gt;show();
        //更新进度条，利用定时器演示
        static int value=0;
        QTimer *timer =new QTimer();
        connect(timer,&amp;QTimer::timeout,this,[=]()&#123;
           pro-&gt;setValue(value);
           value++;
           if(value&gt;pro-&gt;maximum())
           &#123;
               //关掉定时器
               timer-&gt;stop();
               value=0;
               //手动去析构对象
               delete pro;
               delete timer;
           &#125;
        &#125;);

        //点击取消下载，接收到信号，析构对象
        connect(pro,&amp;QProgressDialog::canceled,this,[=]()&#123;
           timer-&gt;stop();
           value=0;
           delete pro;
           delete timer;
        &#125;);


        timer-&gt;start(50);//50毫秒更新一次
&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/Qt-window/image-20230606224819514.png" >
        </sapn>
      </p>

        <!-- 分类文章 -->
        
          <div class="post-categoris-bottom">
            <div class="post-categoris-name">Qt学习</div>
            <ul>
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
                <li class="me base">
                  <a  href="/2023/06/03/Qt-window/" class="post-categoris-bottom-link">
                  QTimer定时器,窗口界面操作
                </a>
                </li>
              
              
            
            
            </ul>

          </div>

        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#QTimer%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8C%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C"><span class="space-toc-text">QTimer定时器，窗口界面操作</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/Xw-oorik/xw-oorik.github.io">Pot ba</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/Xw-oorik/xw-oorik.github.io" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:820735157@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="https://blog.csdn.net/weixin_51609435?spm=1000.2115.3001.5343" target="_blank">
                <i class="ri-pages-fill"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>

<link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"> </script>

<script src="/js/fancybox.js"></script>





<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  Cplusplus部分总结 |    Oorik.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/emoji-18/61/21-64.png" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Oorik.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="sort">
             CATEGORIES
             <div class="categories-outer " id="sort-div">
               <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp%E8%BF%9B%E9%98%B6/">Cpp进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%BF%9B%E9%98%B6/">C进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a></li></ul>
             </div>
          </li>
        
        
        <a href="/search">
          <li class="menu-li  animate__animated  animate__fadeInUp">
            <i class="ri-search-line"></i>
          </li>
        </a>
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Oorik.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
    <a href="/search">  
      <div class="mobile-menu-child  animate__animated  animate__fadeInUp">
        <i class="ri-search-line"></i>
      </div>
    </a>
    
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">Cplusplus部分总结</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">May 22 2023</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h3 id="记录我下班重温cpp的一些笔记。"><a href="#记录我下班重温cpp的一些笔记。" class="headerlink" title="记录我下班重温cpp的一些笔记。"></a>记录我下班重温cpp的一些笔记。</h3><pre><code class="c">new 重载 运算符 返回具体类型 抛异常 不用指定内存大小 多构造对象的过程
malloc 指定内存大小 void* 返回null 
二维数组分配内存
int(*arr)[5]=new int[4][5];//直接全分配好

int **brr=new int*[4];//同下面malloc一个意思
brr[i]=new int[3];

int **crr=(int**)malloc(sizeof(int*)*2);//2行的指针数组
crr[i]=(int*)malloc(sizeof(int)*3);//具体每行的3个元素
</code></pre>
<hr>
<p>this-&gt;  classname *const this</p>
<p>const成员函数中  const classname *const this ，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</p>
<p>this是右值，所以不能取this的地址</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230513202648323.png" >
        </sapn>
      </p>
<p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</p>
<hr>
<p>虚函数可以是内联函数吗？</p>
<p>可以，但是当虚函数表现出多态性就不能内联</p>
<p>多态-》运行期，，内联-》编译期。编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p>
<p><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而<strong>不是对象的指针或引用时才会发生。</strong></p>
<hr>
<p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p>
<p>所以volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p>
<ul>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
<li>volatile多用在多线程</li>
</ul>
<hr>
<p>union任意时刻只有一个数据成员可以持有值</p>
<ol>
<li><strong>默认访问控制符为 public</strong></li>
<li><strong>可以含有构造函数、析构函数</strong></li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li><strong>全局匿名联合必须是静态（static）的</strong></li>
</ol>
<pre><code class="c">union unionTest
&#123;
   unionTest():i(10)&#123;
      cout&lt;&lt;&quot;unionTest i&quot;&lt;&lt;endl;
   &#125;
   int i;
   double d;
&#125;;
//全局匿名的
static union
&#123;

   int i;
   double d;
&#125;;
int main()
&#123;
   unionTest myunion;
   
   //局部匿名union
   union&#123;
      int i;
      double d;
   &#125;;

   cout&lt;&lt;myunion.i&lt;&lt;endl;

   ::i=20;
   cout&lt;&lt;::i&lt;&lt;endl;// 输出全局静态匿名联合的 20

   i=30;
   cout&lt;&lt;i&lt;&lt;endl;// 输出局部匿名联合的 30
&#125;
</code></pre>
<hr>
<p>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</p>
<p>explicit 修饰转换函数时，可以防止隐式转换</p>
<pre><code class="c">struct A
&#123;
    A(int) &#123;&#125;
    operator bool() const &#123; return true; &#125;
&#125;;

struct B
&#123;
    explicit B(int) &#123;&#125;
    explicit operator bool() const &#123; return true; &#125;
&#125;;

void doA(A a) &#123;&#125;

void doB(B b) &#123;&#125;

int main()
&#123;
    A a1(1);     // OK：直接初始化
    A a2 = 1;    // OK：复制初始化
    A a3&#123;1&#125;;     // OK：直接列表初始化
    A a4 = &#123;1&#125;;  // OK：复制列表初始化
    A a5 = (A)1; // OK：允许 static_cast 的显式转换
    doA(1);      // OK：允许从 int 到 A 的隐式转换
    if (a1);                            // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
    bool a6(a1);                   // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
    bool a7 = a1;                    // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
    bool a8 = static_cast&lt;bool&gt;(a1); // OK ：static_cast 进行直接初始化

    B b1(1);     // OK：直接初始化
    B b2 = 1;    // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
    B b3&#123;1&#125;;     // OK：直接列表初始化
    B b4 = &#123;1&#125;;  // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
    B b5 = (B)1; // OK：允许 static_cast 的显式转换
    doB(1);      // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    if (b1);                            // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b6(b1);                     // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b7 = b1;                    // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b8 = static_cast&lt;bool&gt;(b1); // OK：static_cast 进行直接初始化

    return 0;
&#125;
</code></pre>
<hr>
<p>c++11之后使用using可以用来声明继承构造函数</p>
<pre><code class="c">class Base
&#123;
public:
    Base(int va) :m_value(va), m_c(&#39;0&#39;) &#123;&#125;
    Base(char c) :m_c(c), m_value(0) &#123;&#125;
private:
    int m_value;
    char m_c;
&#125;;
 
class Derived :public Base
&#123;
public:
    //使用继承构造函数
    using Base::Base;
 
    //假设派生类只是添加了一个普通的函数
    void display()
    &#123;
//dosomething		
    &#125;
&#125;;
</code></pre>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/SwordArcher/article/details/88717442">https://blog.csdn.net/SwordArcher/article/details/88717442</a> using在继承构造函数中的用法(c++11)</p>
<hr>
<p>c++的多态</p>
<ul>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期&#x2F;运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<p>静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期，即函数地址是早绑定还是晚绑定的。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早绑定。静态多态往往也被叫做静态联编。 动态多态则是指函数调用的地址不能在编译器期间确定，需要在运行时确定，属于晚绑定，动态多态往往也被叫做动太联编</p>
<p><strong>编译期是指把你的源程序交给编译器编译的过程，最终目的是得到obj文件，链接后生成可执行文件（预处理、编译、汇编和链接）。 运行期指的是你将可执行文件交给操作系统（输入文件名，回车）执行、直到程序执行结束</strong>。</p>
<hr>
<h4 id="模板编译与链接"><a href="#模板编译与链接" class="headerlink" title="模板编译与链接"></a>模板编译与链接</h4><p>现在就来看看，编译器对模板是如何编译和链接吧(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jinxiang1224/p/8468272.html">https://www.cnblogs.com/jinxiang1224/p/8468272.html</a>)</p>
<p>当编译器遇到一个template时，不能够立马为他产生机器代码，它必须等到template被指定某种类型。也就是说，函数模板和类模板的完整定义将出现在template被使用的每一个角落，比如遇到上述中的4个语句时，才能确定编译内容，否则编译器没有足够的信息产生机器代码。</p>
<p>对于不同的编译器，其对模板的编译和链接技术也会有所不同，其中一个常用的技术称之为Smart，其基本原理如下：</p>
<ol>
<li><p>模板编译时，以每个cpp文件为编译单位，实例化该文件中的函数模板和类模板</p>
</li>
<li><p>链接器在链接每个目标文件时，会检测是否存在相同的实例；有存在相同的实例版本，则删除一个重复的实例，保证模板实例化没有重复存在。</p>
</li>
</ol>
<p>比如我们有一个程序，包含A.cpp和B.cpp，它们都调用了CThree模板类，在A文件中定义了int和double型的模板类，在B文件中定义了int和float型的模板类；在编译器编译时.cpp文件为编译基础，生成A.obj和B.obj目标文件，即使A.obj和B.obj存在重复的实例版本，但是在链接时，链接器会把所有冗余的模板实例代码删除，保证exe中的实例都是唯一的。编译原理和链接原理，如下所示：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531002904717.png" >
        </sapn>
      </p>
<hr>
<p><strong>问为什么虚继承能解决菱形继承的问题？？？</strong></p>
<p>虚继承底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><p>虚继承用的指针是vbptr，，虚函数的是vfptr</p>
<p>​		所谓虚函数表，是编译器自动为一个带有虚函数的类生成的一块内存空间，其中存储着每一个虚函数的入口地址。由于函数的入口地址可以看成一个指针类型，因此这些虚函数的地址间隔为四个字节。而每一个带有虚函数类的实例，都拥有一个虚函数指针——vptr，在类的对象初始化完毕后，它将指向虚函数表。</p>
<p>虚函数表、虚函数指针是编译期确定的，但是虚函数表里面的虚函数具体的实现方式是运行期确定的。</p>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：<ul>
<li>虚继承<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移量，通过偏移量的指向去解决菱形继承的问题</li>
</ul>
</li>
<li>虚函数<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>常用的一些宏，日志，调试经常用</p>
<p>编译器内置宏：</p>
<p>ANSI C标准中有几个标准预定义宏（也是常用的）：</p>
<ul>
<li><strong>LINE</strong>：在源代码中插入当前源代码行号；</li>
<li><strong>FILE</strong>：在源文件中插入当前源文件名；</li>
<li><strong>DATE</strong>：在源文件中插入当前的编译日期</li>
<li><strong>TIME</strong>：在源文件中插入当前编译时间；</li>
<li><strong>STDC</strong>：当要求程序严格遵循ANSI C标准时该标识被赋值为1；</li>
<li>__cplusplus：当编写C++程序时该标识符被定义，例如__cplusplus199711，__cplusplus201103。</li>
<li><strong>FUNCTION</strong>：调用函数的名称</li>
</ul>
<p>编译器在进行源码编译的时候，会自动将这些宏替换为相应内容。</p>
<p>标识符__LINE__和__FILE__通常用来调试程序；</p>
<p>标识符__DATE__和__TIME__通常用来在编译后的程序中加入一个时间标志，以区分程序的不同版本；</p>
<p>这四个都是预编译宏，不是包含在头文件中的：</p>
<ul>
<li>__FILE__是当前编译的文件的文件名 是一个字符串</li>
<li>__TIME__是当前编译的文件的编译时间 格式是hh:mm:ss 是字符串</li>
<li>__DATE__是当前编译的文件的编译日期 格式是Mmm:dd:yyyy 是字符串</li>
<li>__LINE__是调用该宏语句所在的行数，是个十进制数</li>
</ul>
<pre><code class="c">#include&lt;iostream&gt;
using namespace std;
int main()
&#123;
   cout&lt;&lt;&quot;line:&quot;&lt;&lt;__LINE__&lt;&lt;endl;
   cout&lt;&lt;&quot;file:&quot;&lt;&lt;__FILE__&lt;&lt;endl;
   cout&lt;&lt;&quot;date:&quot;&lt;&lt;__DATE__&lt;&lt;endl;
   cout&lt;&lt;&quot;time:&quot;&lt;&lt;__TIME__&lt;&lt;endl;
   cout&lt;&lt;&quot;version:&quot;&lt;&lt;__cplusplus&lt;&lt;endl;
   cout&lt;&lt;&quot;function:&quot;&lt;&lt;__FUNCTION__&lt;&lt;endl;
&#125;
</code></pre>
<h3 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h3><ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h3 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h3><ul>
<li>私有：线程栈，寄存器，程序计数器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h3 id="有关继承，你要知道"><a href="#有关继承，你要知道" class="headerlink" title="有关继承，你要知道"></a>有关继承，你要知道</h3><ul>
<li>派生类从继承可以继承来所有的成员（变量和方法），析构，友元类，函数不会继承，，同名的函数和变量不会继承，相当于隐藏了，需要自己手动调用</li>
</ul>
<p><del><strong>有的说没有继承来父类的构造和析构，，怎么说呢，个人认为其实是继承下来了，如果没有继承下来，在派生类里面怎么调用父类的构造去初始化继承来的父类的成员呢？</strong></del></p>
<p>复盘，构造不能被继承，初始化列表那种写法是显示调用父类构造</p>
<p>查询C++primer 15.7.4得到：类不会继承默认、拷贝、移动构造函数，如果派生类没有直接定义这些构造函数，编译器会自动为派生类合成这些构造</p>
<p>下面是gpt4的回答：</p>
<p>在C++中，派生类不能继承基类的构造函数和析构函数。这是因为构造函数和析构函数是特殊的成员函数，它们在对象的创建和销毁时自动调用，而不是由派生类继承。特殊的那些函数都不能继承</p>
<p>C++ Primer第五版中第15章第2节中有明确的说明：</p>
<blockquote>
<p>派生类不继承基类的构造函数或析构函数。一个派生类可以调用基类的构造函数，但是不能继承它。同样，一个派生类可以调用基类的析构函数，但是不能继承它。</p>
</blockquote>
<p>引入-》C++11中使用using继承父类构造函数的独特用法</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531002958912.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531003021722.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531003051824.png" >
        </sapn>
      </p>
<pre><code class="c++">class A
&#123;
private:
    int data;
protected:
    A(int a):data(a)&#123;
        cout&lt;&lt;&quot;A()&quot;&lt;&lt;endl;
    &#125;
    ~A()&#123;cout&lt;&lt;&quot;~A()&quot;&lt;&lt;endl;&#125;
&#125;;

class B:public A
&#123;
private:
    int data1;
public:
    B(int a):A(a),data1(a)  //是 显示调用父类构造
    &#123;
        cout&lt;&lt;&quot;B()&quot;&lt;&lt;endl;
    &#125;
    ~B()&#123;cout&lt;&lt;&quot;~B()&quot;&lt;&lt;endl;&#125;
&#125;;
int main(void)
&#123;
    B b(20);

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<ul>
<li>派生类要想初始化继承来的父类的成员，需要调用基类相应的构造函数来初始化</li>
<li>派生类的构造函数和析构，负责初始化和清理派生类的成员</li>
<li>基类的构造和析构，去负责派生类继承来的部分</li>
</ul>
<p>如果B私有继承了A，那么A里面的public和proected相对于B都成了private，B只能在他内部去访问继承下来的这些相对于他成了private的成员，</p>
<p>如果A里面有私有成员，在私有继承的情况下（无论什么继承情况下），父类的私有成员只能被父类本身访问和使用，而不能被派生类或其他外部类访问和使用。因此B去继承A，A的私有东西B根本无法访问的</p>
<p>存疑，无法访问是ok的，但是A的私有属性是否会被继承下来？ 个人认为会被继承，但是无法访问</p>
<p>查询gpt结论是私有成员会被继承，我写了测试demo看内存地址也是存在的</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>对于派生类和基类同名函数，参数也相同，，这种是可以的，毕竟作用域不相同。这种就叫隐藏，派生类对象想要去调和他同名的父类方法，就需要显示去调用了</p>
<h3 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h3><p>当基类指针或引用指向从堆上构建的派生类对象时，基类析构必须要写成虚的</p>
<pre><code class="c++">&#123;
    Base *de=new Devire();
    delete de;
    de=nullptr;
    return 0;
&#125;
</code></pre>
<p>虚函数一定是动态绑定吗？</p>
<p>不是的，只要是对象本身去调用，即使函数写的虚函数，但还是静态绑定。动态绑定也没必要，你动态绑定最后访问的不还是自己的对应的虚函数嘛</p>
<p>其次你在构造函数里面去调用虚函数，发生的也是静态绑定，不会发生动态绑定</p>
<h3 id="一道笔试题：为什么结果是Devire：10-，动态绑定调用到Devire没问题，可是i-为什么是10呢？"><a href="#一道笔试题：为什么结果是Devire：10-，动态绑定调用到Devire没问题，可是i-为什么是10呢？" class="headerlink" title="一道笔试题：为什么结果是Devire：10  ，动态绑定调用到Devire没问题，可是i 为什么是10呢？"></a>一道笔试题：为什么结果是Devire：10  ，动态绑定调用到Devire没问题，可是i 为什么是10呢？</h3><p>因为函数参数压栈这些都是在程序编译阶段，编译阶段编译器只能看到是Base指针调用show，因此i压栈为10，而动态绑定在运行阶段，运行期间发现show是虚函数，且Base指针指向的是Devire对象，所以才会去Devire里调show，因此打印的是Devire，但是i在编译时已经压栈是10了，那么打印出来的i就是10，并不是i&#x3D;20这个默认值，他毕竟没有被压到栈里</p>
<pre><code class="c++">class Base
&#123;
public:
    Base()&#123;
        cout&lt;&lt;&quot;BASe&quot;&lt;&lt;endl;
    &#125;
    virtual ~Base()&#123;
        cout&lt;&lt;&quot;---BASe&quot;&lt;&lt;endl;
    &#125;
    virtual void show(int i=10)
    &#123;
        cout&lt;&lt;&quot;BAse:&quot;&lt;&lt;i&lt;&lt;endl;
    &#125;
 
&#125;;
class Devire:public Base
&#123;
public:
    Devire()&#123;
        cout&lt;&lt;&quot;Devire&quot;&lt;&lt;endl;
    &#125;
     ~Devire()&#123;
        cout&lt;&lt;&quot;---Devire&quot;&lt;&lt;endl;
    &#125;
    virtual void show(int i=20)
    &#123;
        cout&lt;&lt;&quot;Devire:&quot;&lt;&lt;i&lt;&lt;endl;
    &#125;
&#125;;
int main()
&#123;
    Base *de=new Devire();
    de-&gt;show();
    delete de;
    de=nullptr;
    return 0;
&#125;
</code></pre>
<p>上面代码稍微修改一下，把派生类的show方法改为私有，结果还是跟上的一样，思考为什么？</p>
<pre><code class="c">class Devire:public Base
&#123;
public:
    Devire()&#123;
        cout&lt;&lt;&quot;Devire&quot;&lt;&lt;endl;
    &#125;
     ~Devire()&#123;
        cout&lt;&lt;&quot;---Devire&quot;&lt;&lt;endl;
    &#125;
private:    //改为私有的了
    void show(int i=20)
    &#123;
        cout&lt;&lt;&quot;Devire:&quot;&lt;&lt;i&lt;&lt;endl;
    &#125;
&#125;;
</code></pre>
<p>要分清什么事情在编译阶段做的，什么事情在运行阶段做的，，</p>
<p>访问权限是在编译阶段确定的，，只有编译链接完成了才能去运行。在编译阶段编译器看到的还是Base对象去调用show方法，且i&#x3D;10压栈，他的show是公有的，此时代码的访问权限已经被确定了，因此编译是没问题的。。但是到了运行期间，编译器看到指针指的是派生类，就会通过虚表指针找到对应的虚函数去调用，他才不管你什么访问权限呢，因为你编译都通过了说明访问权限啥的代码检查是没问题的</p>
<h3 id="虚继承的问题"><a href="#虚继承的问题" class="headerlink" title="虚继承的问题"></a>虚继承的问题</h3><p>当b虚继承a之后，b类型就会多一个vbptr的指针。当虚继承之后，虚基类的数据就会放在派生类的最下面（原本正常继承来说，继承的东西在上面），然后派生类最上面加一个vbptr。</p>
<p>当虚继承+虚函数是ok的，可以正常实现多态，但是当遇到虚基类指针&#x2F;引用指向派生类对象（堆上new的）的时候，用完需要再去delete虚基类指针，内存回收就会出问题。。把上面的例子改成虚继承，可以试试</p>
<p>知道答案之前，先要记住：<strong>基类指针指向派生类对象，永远指向的是派生类基类部分的起始地址</strong></p>
<p>明白这句话之后问题的答案就显而易见了，原本正常继承的delete没有问题，因为基类部分就是在内存上面，析构从上往下没问题，，但是虚继承了之后，虚基类的内容就会跑到下面部分，指针指向下面部分去析构，但是上面却没有析构，这样就会有内存泄漏问题</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531003112537.png" >
        </sapn>
      </p>
<p>不过我说的这个问题是在windows下vs会这样，，但是linux下g++这种情况，他会自动的给你偏移到起始位置去free的，所以linux下g++这样没问题</p>
<p>tips：上面普通继承里，vfptr为什么画到Base基类部分呢，因为我写的代码派生类的虚函数是从Base继承来的，如果说Base没有虚函数，派生类有虚函数，那么继承图的vfptr就应该画在Devire部分</p>
<h2 id="系统调用hook"><a href="#系统调用hook" class="headerlink" title="系统调用hook"></a>系统调用hook</h2><p>hook是一种技术用来截获和修改应用程序或操作系统发出的系统调用请求。其本质就是<strong>劫持函数调用</strong>。</p>
<h2 id="操作系统的RING0-RING3分层结构"><a href="#操作系统的RING0-RING3分层结构" class="headerlink" title="操作系统的RING0-RING3分层结构"></a>操作系统的RING0-RING3分层结构</h2><p>简单说：RING3是用户空间，RING0是内核空间</p>
<p>Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。</p>
<p>Windows只使用RING0和RING3，RING0只给操作系统用，RING3谁都能用。</p>
<p>如果普通应用程序企图执行RING0指令，则Windows会显示“非法指令”错误信息。因为有CPU的特权级别作保护。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531003151992.png" >
        </sapn>
      </p>
<p><strong>以Linux+x86为例</strong> 操作系统（内核）的代码运行在最高运行级别RING0上，可以使用特权指令，控制中断、修改页表、访问设备等。 应用程序的代码运行在最低运行级别上RING3上，不能做受控操作。如果要做，例如访问磁盘，写文件的操作，则必须通过<strong>系统调用</strong>（函数），执行系统调用的时候，CPU的运行级别会从RING3切换到RING0，并跳转到系统调用对应的内核代码位置执行，这样内核就替我们完成了设备访问的操作，完成之后再从RING0返回RING3。整个过程也称<strong>作用户态和内核态的切换</strong></p>
<p>如果要想做一个劫持函数：三种实现方法：</p>
<ol>
<li>在RING3这种用户空间，我们可以编写自己的动态库，利用LD_PRELOAD优先加载同名的自定义函数  （比如 自定义strcmp来覆盖C标准库的strcmp）</li>
<li>对于RING0内核空间，找到程序调用对应的汇编命令，修改对应的offset地址  （call  0xc106d75c <vfs_read>）让他跳到新的内核函数</li>
<li>利用利用0x80中断劫持system_call，获取sys_call_table的基地址，修改指定函数offset对应的系统调用了</li>
</ol>
<p><strong>这块具体代码还不是很懂，涉及汇编和底层。。留坑等以后牛逼了，学习一下–</strong></p>
<p><strong>出处：<a target="_blank" rel="noopener" href="https://stibel.icu/md/c++/function/c++-function-Linux_Hook.html">C++函数 - Linux系统调用Hook )</a></strong></p>
<h2 id="C-函数-getopt函数"><a href="#C-函数-getopt函数" class="headerlink" title="C++函数 - getopt函数"></a>C++函数 - getopt函数</h2><p>linux下解析传入命令的，实现命令行参数的解析和处理。</p>
<pre><code class="c++">int getopt(int argc,char * const argv[ ],const char * optstring);
</code></pre>
<p>参数argc和argv分别代表参数个数和内容，参数 optstring为选项字符串</p>
<p>定义一个optstring字符串，用于指定支持的命令行选项，程序用while调getopt解析输入的命令行，解析到相应的字符，在optstring有支持的，去做对应的处理就行</p>
<p>省略…补坑，暂时没用过</p>

        <!-- 分类文章 -->
        
          <div class="post-categoris-bottom">
            <div class="post-categoris-name">Cpp进阶</div>
            <ul>
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
                <li class="base">
                  <a  href="/2023/05/22/auto1/" class="post-categoris-bottom-link">
                  auto关键字进阶
                </a>
                </li>
              
              
            
            
            
              
                <li class="me base">
                  <a  href="/2023/05/22/cplus/" class="post-categoris-bottom-link">
                  Cplusplus部分总结
                </a>
                </li>
              
              
            
            
            
              
                <li class="base">
                  <a  href="/2023/05/22/cpp%E6%A8%A1%E6%9D%BF1/" class="post-categoris-bottom-link">
                  Cpp模板细讲
                </a>
                </li>
              
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            </ul>

          </div>

        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8hook"><span class="space-toc-text">系统调用hook</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84RING0-RING3%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="space-toc-text">操作系统的RING0-RING3分层结构</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#C-%E5%87%BD%E6%95%B0-getopt%E5%87%BD%E6%95%B0"><span class="space-toc-text">C++函数 - getopt函数</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/Xw-oorik/xw-oorik.github.io">Pot ba</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/Xw-oorik/xw-oorik.github.io" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:820735157@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="https://blog.csdn.net/weixin_51609435?spm=1000.2115.3001.5343" target="_blank">
                <i class="ri-pages-fill"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>

<link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"> </script>

<script src="/js/fancybox.js"></script>


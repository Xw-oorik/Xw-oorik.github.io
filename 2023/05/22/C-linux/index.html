


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  C系统编程 |    Oorik.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/emoji-18/61/21-64.png" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Oorik.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="sort">
             CATEGORIES
             <div class="categories-outer " id="sort-div">
               <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp%E8%BF%9B%E9%98%B6/">Cpp进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%BF%9B%E9%98%B6/">C进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a></li></ul>
             </div>
          </li>
        
        
        <a href="/search">
          <li class="menu-li  animate__animated  animate__fadeInUp">
            <i class="ri-search-line"></i>
          </li>
        </a>
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Oorik.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
    <a href="/search">  
      <div class="mobile-menu-child  animate__animated  animate__fadeInUp">
        <i class="ri-search-line"></i>
      </div>
    </a>
    
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">C系统编程</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">May 22 2023</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <p>[Toc]</p>
<h1 id="练气期"><a href="#练气期" class="headerlink" title="练气期"></a>练气期</h1><p>os就是操作系统，，linux，windows</p>
<h3 id="文件io标准库函数和系统调用关系"><a href="#文件io标准库函数和系统调用关系" class="headerlink" title="文件io标准库函数和系统调用关系"></a>文件io标准库函数和系统调用关系</h3><p>fopen c的库函数，open系统调用，用fopen，就是fopen(3)库函数，用fopen底层会调open系统调用，调的open其实就是open(2)</p>
<p>man帮助的顺序</p>
<p>标准库函数都是在用户空间调用的</p>
<p>fopen调用open，open打开指定文件，返回一个文件描述符（一个int类型的编号），（分配一个FILE结构体，其中包含该文件的描述符，io缓冲区和当前读写位置等信息）返回增FILE结构体的地址</p>
<p>fd&#x3D;FILE*.      这个FILE * 被经常称作 句柄或者上下文。意思就是我们只需要操作句柄，但是结果表现的是我们对于内部文件做了操作</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531004721672.png" >
        </sapn>
      </p>
<hr>
<p>然后fgetc(fd) ，会发现这些库函数都是操作的对应的数据结构，而不是真正的文件，而真正的文件都是通过系统调用操作的</p>
<p>fgetc也是调read </p>
<p>fgets是先通过FILE*参数找到文件的描述符，io缓冲区和当前读写位置，判断能否从io缓冲区读到下一个字符，如果能读到就直接返回该字符。否则调用read，把文件描述符传进去，让内核读取改文件数据到io缓冲区，然后返回下一个字符</p>
<p>比如fgets要读A，，但是io缓冲区空的，所以就会调read，让内核去文件读，读到缓冲区，假如读了ABC到缓冲区，然后返回缓冲区里的A就行，读写位置移动。假如在调一个fgets，就会直接从缓冲区读了，而调不到read系统调用了。。</p>
<p>read只是缓冲区空了，才让内核去文件读东西到缓冲区</p>
<hr>
<p>fputc会调write给文件写</p>
<p>同样也是看io缓冲区是否有空间，有空间了，就写到缓冲区，，当缓冲区满了，才会调用write，让内核把缓冲区的内容写进文件</p>
<hr>
<p>fclose -&gt;close</p>
<p>如果调用fclose，缓冲区还有数据，那么调fclose底层会调write把缓冲区的内容写到文件，这样用户空间才是空的，然后才调用close关闭文件，释放FILE结构体和缓冲区</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531004828050.png" >
        </sapn>
      </p>
<p>缓冲区就好像菜鸟驿站一样，存到一定量了或者触发某些条件了才去发快递，在驿站收快递同理</p>
<p>缓冲区分为：全缓冲，行缓冲，无缓冲</p>
<p>全缓冲就是只有缓冲区填满了才会触发系统调用</p>
<p>行缓冲就是当出现换行\n或者填满 都会触发系统调用</p>
<p>无缓冲就是有东西就调用系统调用，像stderr输出错误的就是无缓冲，stdout输出屏幕就是行缓冲</p>
<p>注意linux下一切皆文件,open能打开任意的东西</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a><strong>open</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531004901750.png" >
        </sapn>
      </p>
<h3 id="close"><a href="#close" class="headerlink" title="close"></a><strong>close</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531004938213.png" >
        </sapn>
      </p>
<p>比如打开三个文件abc，先打开a 打开b，然后关闭a ，再打开c ，最后关闭b，关闭c</p>
<p>打印他们的文件描述符fd会发现是3 4 3，，为啥？因为0 1 2是标准输入输出和错误。最新的文件描述符只能从后面开始，a是3 ，b是4。当a关闭之后，再open，此时3号描述符是空的了，且返回当前最小的fd给文件，那么c的fd就会被分配给3 </p>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a><strong>read</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005023371.png" >
        </sapn>
      </p>
<p>read读的就是内核里面真正的文件位置，c标准库调的读返回的是那个缓冲区buff的位置,如果读到文件尾就提前返回了，即使没有读够count个字节；从终端设备读，是以行读的，遇到换行就读完退出</p>
<p>小问题tips:  shell是个程序，一直在监听stdin。。比如执行程序 .&#x2F;a.out ，shell就退居幕后， .&#x2F;a.out这个程序出来监听stdin，，我们输入20个字符，但是.&#x2F;a.out这个假如只读10个字节，读完之后a.out退出，，那么shell提到前面，继续监听stdin，那么他就会读到stdin输入流剩下那十个字节，把他当成命令去执行。。这样就会出问题</p>
<pre><code class="c">#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;stdio.h&gt;
#include&lt;errno.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
int main(int argc,int *argv[])
&#123;
    if(argc&lt;2)&#123;							   个人 组 其他
        printf(&quot;--help&quot;);                  读写执行
        return -1;                         rwx
    &#125;                                      rw- r-- r--
   // int fd=open(argv[1],O_WRONLY|O_CREAT,0644);
    int fd=open(argv[1],O_RDONLY);
    if(fd&lt;0)&#123;
        perror(&quot;OPEN err&quot;);
        return -1;
    &#125;
    else&#123;
        perror(&quot;xxx&quot;);
    &#125;
    char buff[1024];
    ssize_t n=read(fd,buff,10);
    
    int fc=open(&quot;b.txt&quot;,O_WRONLY|O_CREAT,0644);
    write(fc,buff,10);
    close(fd);
    close(fc);
    return 0;
&#125;
    ./main  a.txt
argv    0   1
</code></pre>
<h3 id="非阻塞的读写"><a href="#非阻塞的读写" class="headerlink" title="非阻塞的读写"></a><strong>非阻塞的读写</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005050125.png" >
        </sapn>
      </p>
<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a><strong>fcntl</strong></h3><p>用来改变一个已打开的文件的属性，而不必重新open文件，可以设置读写，追加，非阻塞等标志,也能去给文件上锁，上了之后就是说这个文件这一段时间只能我这个进程去用。</p>
<p>fcntl功能很多</p>
<pre><code class="c">#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;stdio.h&gt;
#include&lt;errno.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
int main()
&#123;
    int flags=0;
    //给标准输入设置非阻塞权限
    if((flags=fcntl(STDIN_FILENO,F_GETFL))&lt;0)
    &#123;
        perror(&quot;get flags err\n&quot;);
        exit(-1);
    &#125;
    flags|=O_NONBLOCK;
    if((flags=fcntl(STDIN_FILENO,F_SETFL,flags))&lt;0)
    &#123;
        perror(&quot;set flags err\n&quot;);
        exit(-1);
    &#125;

     &#39;&#39;&#39;读写数据
    return 0;
&#125;
</code></pre>
<p>流的重定向   标准输入流&gt;      &lt;标准输出流 </p>
<h3 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a><strong>mmap内存映射</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005115279.png" >
        </sapn>
      </p>
<p>addr如果为空，内核会自己在进程地址空间选择合适的地址建立映射，我们可以给addr一个地址，这个地址只不过是建议的，内核会从给的这个地址开始往上找合适的位置，真正的映射的首地址可以通过mmap返回值拿到</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005143307.png" >
        </sapn>
      </p>
<p>linux 可以用 -txl -tc 文件，查看文件里面每个字符的ASCII值的16进制</p>
<pre><code class="c">#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;stdio.h&gt;
#include&lt;errno.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/mman.h&gt;
int main(int argc,int *argv[])
&#123;
    if(argc&lt;2)&#123;							
        printf(&quot;--help&quot;);                  
        return -1;                      
    &#125;                                      
   // int fd=open(argv[1],O_WRDONLY|O_CREAT,0644);
    int fd=open(argv[1],O_RDWR);
    if(fd&lt;0)&#123;
        perror(&quot;OPEN err&quot;);
        return -1;
    &#125;
    else&#123;
        perror(&quot;xxx&quot;);
    &#125;
    char *p=mmap(NULL,10,PROT_WRITE,MAP_SHARED,fd,0);
    for(int i=0;i&lt;5;++i)
    &#123;
        p[i]=&#39;a&#39;;
    &#125;
    munmap(p,10);
    close(fd);

    return 0;
&#125;
</code></pre>
<h3 id="ext2文件系统"><a href="#ext2文件系统" class="headerlink" title="ext2文件系统"></a><strong>ext2文件系统</strong></h3><p>树状结构</p>
<p>linux早期的文件系统</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005224156.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005309692.png" >
        </sapn>
      </p>
<p><strong>inode表要理解，，很重要. 一个文件除了数据之外的别的标识都在存在inode表里面。inode就是对整个文件的管理信息表</strong> ，，注意每个文件的文件名没有存在自己的inode或者数据块中，，而是存在此文件当前的上级目录中，目录中数据块会存当前目录下的文件夹，文件的名字</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005334099.png" >
        </sapn>
      </p>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a><strong>stat</strong></h3><p>stat系统调用或者liunx封装的stat命令，可以查当前文件的状态,inode，blocks,大小，链接数，权限等</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005409584.png" >
        </sapn>
      </p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h3><p>软链接就是真的重新创建了一个文件，类似windows的快捷方式，，硬链接只是给文件起了别名，给硬链接数+1了，</p>
<h3 id="遍历目录数据块的记录"><a href="#遍历目录数据块的记录" class="headerlink" title="遍历目录数据块的记录"></a><strong>遍历目录数据块的记录</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005442301.png" >
        </sapn>
      </p>
<h3 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a><strong>VFS虚拟文件系统</strong></h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005501741.png" >
        </sapn>
      </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005534365.png" >
        </sapn>
      </p>
<h3 id="dup和dup2做重定向"><a href="#dup和dup2做重定向" class="headerlink" title="dup和dup2做重定向"></a><strong>dup和dup2</strong>做重定向</h3><p>oldfd去覆盖newfd，执行完该命令后，newfd如果在使用，就关闭，完了newfd就指向oldfd指向的那个文件</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005637653.png" >
        </sapn>
      </p>
<pre><code class="c">&#39;&#39;&#39;头文件&#39;&#39;&#39;

int main()
&#123;
    int fd,save_fd;
    if((fd=open(&quot;test.txt&quot;,O_RDWR))&lt;0)
    &#123;
        perror(&quot;open err\n&quot;);
        exit(1);
    &#125;
    
    save_fd=dup(1);
    dup2(fd,1);
      close(fd);
    char*buf=&quot;nihao&quot;;
    write(1,buf,strlen(buf));
    dup2(save_fd,1);
    write(1,buf,strlen(buf));
    close(save_fd);
    return 0;
&#125;
</code></pre>
<p>上面dup和dup2做个文件重定向的逻辑解释</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005703843.png" >
        </sapn>
      </p>
<h1 id="神通期"><a href="#神通期" class="headerlink" title="神通期"></a>神通期</h1><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>复制进程，，调用失败返回-1</p>
<p>调用成功：父亲fork成功拿到儿子的pid，，儿子被成功复制出来之后儿子拿到的是0</p>
<pre><code class="c">#include&lt;unistd.h&gt;
pid_t fork(void)
    
</code></pre>
<p>不同的地方：pid，内存锁没有被继承，</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005729329.png" >
        </sapn>
      </p>
<p>fork之后就会进到内核态，子进程复制出来之后，切回用户态，此时父进程和子进程两个此时都是处于就绪状态，所以不加控制的话，他们的运行顺序是由cpu去调度</p>
<h4 id="两句话说清孤儿和僵尸进程"><a href="#两句话说清孤儿和僵尸进程" class="headerlink" title="两句话说清孤儿和僵尸进程"></a>两句话说清孤儿和僵尸进程</h4><p>bash起来，运行a程序（这个a程序其实就是bash的儿子），此时bash就退到后台去，cpu把a程序占着，此时a程序fork出一个a1子进程，当a程序先结束，会产生一个尸体（退出码），bash睡的好好的，被尸体这个东西给惊醒了，那么bash就会起来去给a程序收尸，此时bash其实就是可以继续正常去执行新的程序了，但此时 a1这个对于bash来说的这个孙子进程还没结束，但是他的父亲a已经死了，此时就称a1这个进程是孤儿进程，，那等a1执行完了谁给他收尸呢？其实是被一个叫init进程去收尸了，所以此时a1他的父进程就成了init，其实当他的老父亲a先于他结束的那一刻，a1的父亲就成了init进程，init就是操作系统中开天辟地中的老祖宗，第一个进程。</p>
<pre><code class="c">set follow-fork-mode parent
set follow-fork-mode child
多进程去gdb，模式设置，看是去跟随哪个进程
</code></pre>
<h4 id="exec族"><a href="#exec族" class="headerlink" title="exec族"></a>exec族</h4><p>操作系统多个程序就怎么跑的，就是通过fork+exec</p>
<p>exec就是用新程序去替换你刚刚新fork出来的那个子进程</p>
<p>如果exec调用成功，就会加载新的程序从启动代码处开始执行，就不在返回了</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005748066.png" >
        </sapn>
      </p>
<p>试试这个demo代码：</p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdlib.h&gt;
int main()
&#123;
    printf(&quot;path value=[%s]\n&quot;,getenv(&quot;PATH&quot;));
    setenv(&quot;PATH&quot;,&quot;hell&quot;,1);  //在当前程序里面把path环境变量改成hell了
                          //相当于你子进程去改了环境变量
                        //但你的终端的好比父进程，他的path其实是没有被改的，所以不用担心        完了你在终端 $PATH查看一下就知道了
    extern char** environ;
    for(int i=0;environ[i]!=NULL;++i)
    &#123;
        printf(&quot;%s\n&quot;,environ[i]); #把你操作系统的环境变量全打印出来了
    &#125;
    return 0;
&#125;
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005813376.png" >
        </sapn>
      </p>
<h4 id="wait，waitpid"><a href="#wait，waitpid" class="headerlink" title="wait，waitpid"></a>wait，waitpid</h4><p>一个进程终止是会关闭所有的文件描述符，释放在用户空间分配的内存，但他的pcb还保存的，内核在pcb中还保存一些信息，如果是正常终止则保存着退出状态，是异常退出则保存着导致该进程终止的信号是哪个</p>
<p>用wait&#x2F;waitpid可以获取这些信息，然后彻底清除这个进程</p>
<p>查看状态信息，Z+就代表当前进程是个僵尸进程</p>
<p>kill-9没法杀已经是僵尸的进程，，可以杀僵尸进程他爹，这样僵尸就会成孤儿，被init收尸</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005830775.png" >
        </sapn>
      </p>
<h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005845507.png" >
        </sapn>
      </p>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>pipe，，信息一个时刻只能单向流通，父子进程用，fd[0]读端，fd[1]写端</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005901177.png" >
        </sapn>
      </p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/wait.h&gt;

int main()
&#123;
    int fd[2];
    char buf[20];
    if(pipe(fd)&lt;0)
    &#123;
        perror(&quot;pipe&quot;);
        exit(1);
    &#125;
    pid_t pid=fork();
    if(pid&lt;0)
    &#123;
        perror(&quot;fork&quot;);
        exit(1);
    &#125;
    else if(pid=0)
    &#123;
        close(fd[0]);
        write(fd[1],&quot;hello pipe\n&quot;,11);
        wait(NULL);
    &#125;
    else&#123;
        close(fd[1]);
        int n=read(fd[0],buf,20);
        write(1,buf,n);//写到输出到屏幕上
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="管道popen和pclose，，两个集成化的函数"><a href="#管道popen和pclose，，两个集成化的函数" class="headerlink" title="管道popen和pclose，，两个集成化的函数"></a>管道popen和pclose，，两个集成化的函数</h4><p>这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭管道的不使用端，exec一个cmd命令，等待命令终止</p>
<pre><code class="c">FILE *popen(const char*commmand,const char*type);
返回，若成功则为文件指针，若出错，则为NULL

int pclose(FILE*stream)
 返回command的终止状态，出错返回-1
</code></pre>
<p>popen打开管道，fork，调用exec执行command的并且返回一个标准文件io的指针</p>
<p>type为r ，将文件指针连接到cmd的标准输出，，w连接到cmd的标准输入</p>
<pre><code class="c">&#123;
    FILE*fp=popen(&quot;cat ./hexo.txt&quot;,&quot;r&quot;);  //打印到屏幕上
        
    
    FILE*fp=popen(&quot;./hexo&quot;,&quot;w&quot;);  //运行hexo这个程序，往屏幕上输出
    
&#125;
</code></pre>
<h4 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h4><p>不拘泥于父子进程</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531005919050.png" >
        </sapn>
      </p>
<h4 id="共享内存，最快的ipc"><a href="#共享内存，最快的ipc" class="headerlink" title="共享内存，最快的ipc"></a>共享内存，最快的ipc</h4><p>通过ftok把内核中共享内存那块结构key获取，然后用shmget把key传进去，拿到这块共享内存id，通过shmat把共享内存和用户空间进行映射，后面用户通过映射的地址进行操作</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531010004630.png" >
        </sapn>
      </p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>整体流程</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531010018920.png" >
        </sapn>
      </p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>kill -l  可以列出系统支持的信号</p>
<ol>
<li><code>ulimit -a</code> 命令用于显示当前 shell 进程的所有限制。而 <code>ulimit -c</code> 命令用于设置或显示当前 shell 进程的 core 文件大小限制。</li>
</ol>
<ul>
<li><p>Core 文件是在程序运行发生错误时操作系统自动生成的一种文件，并记录了程序错误发生时的内存状态、寄存器内容等信息。通过分析 Core 文件可以定位并修复程序错误。</p>
</li>
<li><p>程序段错误（Segmentation Fault）通常是指程序在访问无效的内存地址或者尝试对只读内存进行写操作时，由操作系统抛出的一种信号，导致程序异常退出或者崩溃。这通常是由于程序代码编写不当、内存泄漏等问题导致的。</p>
</li>
<li><p>Core Dump（核心转储），通常指在程序运行出现严重错误导致程序终止时，操作系统会自动保存程序在此时的内存状态和在运行过程中的其他数据到磁盘上，以 Core 文件的形式保存，以便程序员或开发人员在出现问题时进行程序调试。</p>
<p><strong><font color='orange'>发生core dump其实程序错误就是生成core文件了，一般core文件的大小默认的是0，0这个大小的话，系统默认是不会产生core文件的，如果想产生core文件就得修改大小，用ulimit -a，查看一下系统现在这个core的size是多少，完了用<code>ulimit -c</code>去设置一下core文件大小，这样程序错误发生core dump才能生成core 文件，我们才能根据core文件去定位错误，出现core文件了，用gdb +你出错的程序+生成的core文件 可以去调式 ，操作比如：gdb进去用bt查看调用堆栈情况</font></strong></p>
</li>
</ul>
<h3 id="三个函数越来越具体了"><a href="#三个函数越来越具体了" class="headerlink" title="三个函数越来越具体了"></a>三个函数越来越具体了</h3><p>abort很强，无论如何abort都会让你这个程序终止，属于异常终止，程序结束后会产生core dump</p>
<h3 id="有关exit"><a href="#有关exit" class="headerlink" title="有关exit"></a>有关exit</h3><p>在Linux&#x2F;Unix系统中，exit命令可以让进程（包括shell进程）退出，并返回一个退出状态码。一般情况下，该命令有以下几种情况：</p>
<ol>
<li>exit 0：表示正常退出，返回状态码为0。该状态码表示程序成功执行完成。</li>
<li>exit 1-255：表示异常退出，返回状态码为1到255。此时，状态码的含义由程序员自行定义，不同状态码代表不同的出错原因。</li>
<li>exit -n：用于在脚本中设置退出状态码。其中，-n表示状态码，表示程序在执行完当前命令后，退出并返回该状态码。</li>
<li>exit：表示不带参数的exit命令，这时会直接退出当前进程，但不会返回状态码，这种情况也可以被认为是正常退出，默认会返回状态码0。</li>
</ol>
<p>需要注意的是，exit命令只是让当前进程退出，并不会影响其他进程。如果想要让某个进程的子进程也一并退出，可以使用kill命令来发送SIGTERM（或其他信号）信号，以达到强制退出的目的。</p>
<h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>alarm函数可以设置一个闹钟，告诉内核在多少秒之后给当前进程法sigalrm信号</p>
<p>一般使用该函数来进行定时任务的处理。alarm只有一个定时器，比如我刚开始设置5s，然后睡眠3s，这时候还有2s才会发信号退出，此时我在设置alarm为5s，定时器就又成剩的2s变成5s，而不会2s加5s变成7s</p>
<h3 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531010041472.png" >
        </sapn>
      </p>
<p>如果在进程解除对某个信号的阻塞之前这种信号产生过多次，怎么处理的？</p>
<p>linux：是这么搞的，对于常规信号34号之前的，如果产生多次，只计算一次。比如你按了好多次ctrl+c，他操作系统都会认为是一次，等不阻塞了，ctrl+c就成功退出了。</p>
<p>对于实时信号34号之后的，在递达之前产生多次，会依次放在一个队列里面</p>
<p><strong>阻塞信号集也叫做当前进程的信号屏蔽字</strong></p>
<p>对于pending和block这俩信号集，0就是通过，1不通过；可以通过信号集的函数，去设置我们设置的信号集合是否阻塞的状态，如果设置了阻塞，相当于这个信号你就收不到了，对应block位置成1</p>
<p>示例：如上图，我们可以把（1,2,3,4）号信号，这个信号集去全都通过信号集函数去设置阻塞的状态1，把他们加到信号屏蔽字中，之后我们对于这四个信号就收不到了</p>
<p>不能理解我说的这句话，看看gpt理解的：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531010116008.png" >
        </sapn>
      </p>
<h4 id="相关的流程函数如下："><a href="#相关的流程函数如下：" class="headerlink" title="相关的流程函数如下："></a>相关的流程函数如下：</h4><p>信号屏蔽字是一种用于控制进程对信号的接收和处理的机制，可以通过设置信号屏蔽字来屏蔽或解除屏蔽某些信号。在Linux&#x2F;Unix系统中，可以使用sigprocmask函数和相关函数对信号屏蔽字进行操作。</p>
<ol>
<li>sigprocmask函数</li>
</ol>
<p>sigprocmask函数用于设置或获取当前进程的信号屏蔽字，其原型如下：</p>
<pre><code class="c">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
</code></pre>
<p>其中，参数how用于指定屏蔽字需要进行的操作类型，可以选择以下值：</p>
<ul>
<li>SIG_BLOCK：加入（阻塞）信号集</li>
<li>SIG_UNBLOCK：移除（解除阻塞）信号集</li>
<li>SIG_SETMASK：设置（替换）信号集</li>
</ul>
<p>参数set用于指定需要设置的信号集，参数oldset用于记录原先设置的信号集。</p>
<p><strong>sigprocmask</strong>函数的使用方法如下：</p>
<p>（1）创建一个信号集</p>
<p>使用sigemptyset函数清空一个信号集，并使用sigaddset函数向其中加入需要设置的信号。</p>
<p>（2）设置信号屏蔽字</p>
<p>使用sigprocmask函数设置进程的信号屏蔽字，将信号集中的相应信号加入或移除出屏蔽字。</p>
<ol>
<li>sigaddset和sigemptyset函数</li>
</ol>
<p>sigaddset函数用于向信号集中添加一个信号，其原型如下：</p>
<pre><code class="c">int sigaddset(sigset_t *set, int signum);
</code></pre>
<p>其中，参数set为要操作的信号集，参数signum为需要添加的信号编号。</p>
<p>sigemptyset函数用于清空一个信号集，其原型如下：</p>
<pre><code class="c">int sigemptyset(sigset_t *set);
</code></pre>
<p>其中，参数set为要操作的信号集。</p>
<p>使用这两个函数的步骤如下：</p>
<p>（1）定义一个空信号集：</p>
<pre><code class="c">sigset_t myset;
sigemptyset(&amp;myset);
</code></pre>
<p>（2）向信号集中加入要操作的信号：</p>
<pre><code class="c">sigaddset(&amp;myset, SIGUSR1);
</code></pre>
<ol>
<li>sigismember函数</li>
</ol>
<p>sigismember函数用于查询一个信号是否在信号集中，其原型如下：</p>
<pre><code class="c">int sigismember(const sigset_t *set, int signum);
</code></pre>
<p>其中，参数set为要操作的信号集，参数signum为需要查询的信号编号。如果查询到信号在信号集中，则返回1；否则返回0。</p>
<p>2.sigpending用来检查操作未决信号集</p>
<pre><code class="c">int sigpending(sigset_t *set);
</code></pre>
<p>做一个简单示例，加入阻塞信号集，判定在不在未决信号集里面</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
void handler(int sig)
&#123;
    printf(&quot;Signal %d received.\n&quot;, sig);
&#125;
int main()
&#123;
    // 设置信号处理程序
    signal(SIGINT, handler);

    // 创建一个信号集
    sigset_t set;

    // 初始化信号集，将所有信号都清除
    sigemptyset(&amp;set);

    // 将SIGINT信号添加到信号集中
    sigaddset(&amp;set, SIGINT);

    // 阻塞SIGINT信号
    sigprocmask(SIG_BLOCK, &amp;set, NULL);

    // 检查是否有未决的信号
    if (sigpending(&amp;set) == 0)
    &#123;
        if (sigismember(&amp;set, SIGINT))
        &#123;
            printf(&quot;There is a pending SIGINT signal.\n&quot;);
        &#125;
    &#125;
    // 解除阻塞
    sigprocmask(SIG_UNBLOCK, &amp;set, NULL);
    return 0;
&#125;
</code></pre>
<p>这些函数能够允许我们对信号屏蔽字进行正确有效的操作，有助于我们控制程序对信号的处理。</p>
<h3 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h3><p>我们自己自定义相应的信号处理函数</p>
<p>对于我们自定义的信号处理，操作系统总是在内核回退到用户空间之前这个时刻去处理，这样的效率会高，如果每次遇到信号我都要从用户空间跑到内核去处理，再回退，这样效率很低。流程如下图：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/../images/C-linux/image-20230531010136501.png" >
        </sapn>
      </p>
<h4 id="pause函数可以使调用进程挂起，直到信号到达"><a href="#pause函数可以使调用进程挂起，直到信号到达" class="headerlink" title="pause函数可以使调用进程挂起，直到信号到达"></a>pause函数可以使调用进程挂起，直到信号到达</h4><p>sigsuspend函数包含了pause的挂起等待功能，同时解决了时序竞争的问题，在对时序有严格要求的场合要用sigsupend</p>

        <!-- 分类文章 -->
        
          <div class="post-categoris-bottom">
            <div class="post-categoris-name">C进阶</div>
            <ul>
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
                <li class="me base">
                  <a  href="/2023/05/22/C-linux/" class="post-categoris-bottom-link">
                  C系统编程
                </a>
                </li>
              
              
            
            
            
              
            
            
            
              
            
            
            
              
                <li class="base">
                  <a  href="/2023/05/22/c%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-categoris-bottom-link">
                  C多线程
                </a>
                </li>
              
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            </ul>

          </div>

        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="space-toc-text">信号</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/Xw-oorik/xw-oorik.github.io">Pot ba</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/Xw-oorik/xw-oorik.github.io" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:820735157@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="https://blog.csdn.net/weixin_51609435?spm=1000.2115.3001.5343" target="_blank">
                <i class="ri-pages-fill"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>

<link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"> </script>

<script src="/js/fancybox.js"></script>


<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt信号槽</title>
      <link href="/2023/06/03/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
      <url>/2023/06/03/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="QT信号槽"><a href="#QT信号槽" class="headerlink" title="QT信号槽"></a>QT信号槽</h2><p><font color=pink>所谓信号槽，实际就是观察者模式 (发布 - 订阅模式)。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发</font></p><p>在 Qt 中我们需要使用 QOjbect类中的 connect去连接信号和信号槽函数</p><pre><code class="c">QMetaObject::Connection QObject::connect(        const QObject *sender, PointerToMemberFunction signal,         const QObject *receiver, PointerToMemberFunction method,         Qt::ConnectionType type = Qt::AutoConnection);参数:  - sender:   发出信号的对象  - signal:   属于sender对象, 信号是一个函数, 这个参数的类型是函数              指针, 信号函数地址  - receiver: 信号接收者  - method:   属于receiver对象, 当检测到sender发出了signal信号,               receiver对象调用method方法，信号发出之后的处理动作 //  参数 signal 和 method 都是函数地址, 因此简化之后的 connect() 如下:connect(const QObject *sender, &amp;QObject::signal,         const QObject *receiver, &amp;QObject::method);</code></pre><p>使用connect()进行信号槽连接的注意事项:</p><p>connect函数相对于做了信号处理动作的注册<br>调用conenct函数的sender对象的信号并没有产生, 因此receiver对象的 method 也不会被调用<br>method槽函数本质是一个回调函数, 调用的时机是信号产生之后, 调用是Qt框架来执行的<br>connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功</p><p>按钮就是信号的发送者，窗口接收发来的信号去处理</p><h4 id="标准槽函数"><a href="#标准槽函数" class="headerlink" title="标准槽函数"></a>标准槽函数</h4><p><strong>示例：</strong></p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/image-20230604215017429.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/image-20230604215338683.png" >        </sapn>      </p><p><strong>处理过程：程序运行，点击按钮，关闭窗口</strong></p><p>在mainwindow窗口里面做如下操作，对应ui界面的closebt这个按钮，clicked点击发信号，发给this当前窗口对象，当前窗口接收到，做出close这个操作</p><pre><code class="cpp">MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;closebt,&amp;QPushButton::clicked,this,&amp;MainWindow::close);&#125;</code></pre><p>当然了标准的槽函数，就是那个处理函数肯定不能满足我们日常需求，所以我们需要自定义槽函数（回调）</p><h3 id="自定义信号槽"><a href="#自定义信号槽" class="headerlink" title="自定义信号槽"></a>自定义信号槽</h3><p>如果想要在QT类中自定义信号槽, 需要满足一些条件, 并且有些事项也需要注意:</p><ol><li>要编写新的类并且让其继承Qt的某些标准类</li><li>这个新的子类必须从QObject类或者是QObject子类进行派生</li><li>在定义类的头文件中加入 Q_OBJECT 宏</li></ol><pre><code class="cpp">// 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏：class MyMainWindow : public QWidget&#123;    Q_OBJECT    ......&#125;</code></pre><p><strong>demo:</strong></p><p>构建一个son和father类</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/image-20230604220903942.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/image-20230604221703295.png" >        </sapn>      </p><p>father.h</p><pre><code class="cpp">#ifndef FATHER_H#define FATHER_H#include &lt;QObject&gt;class father : public QObject&#123;    Q_OBJECTpublic:    explicit father(QObject *parent = nullptr);public:    //槽函数    void eatrice();&#125;;#endif // FATHER_H</code></pre><p>mainwindow.h</p><pre><code class="cpp">#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include&quot;son.h&quot;#include&quot;father.h&quot;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    MainWindow(QWidget *parent = nullptr);    ~MainWindow();    void eating();//槽函数private:    Son *s;    father* f;    Ui::MainWindow *ui;&#125;;#endif // MAINWINDOW_H</code></pre><p>son.h</p><pre><code class="cpp">#ifndef SON_H#define SON_H#include &lt;QObject&gt;class Son : public QObject&#123;    Q_OBJECTpublic:    explicit Son(QObject *parent = nullptr);signals:    //信号函数    void eat();&#125;;#endif // SON_H</code></pre><p><strong>加了signal关键字，就不用再去定义了，只需要声明</strong></p><p>father.cpp</p><p>做出信号槽函数定义</p><pre><code class="cpp">#include &quot;father.h&quot;#include&lt;QDebug&gt;father::father(QObject *parent) : QObject(parent)&#123;&#125;void father::eatrice()&#123;    qDebug()&lt;&lt;&quot;来吃大米饭.&quot;;&#125;</code></pre><p>son.cpp什么也不做，因为signal带定义，不需要我们自己去cpp文件重写具体实现</p><p>mainwindow.cpp</p><pre><code class="cpp">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    s=new Son;    f=new father;    connect(s,&amp;Son::eat,f,&amp;father::eatrice);    connect(ui-&gt;eating,&amp;QPushButton::clicked,this,&amp;MainWindow::eating);    connect(ui-&gt;closebt,&amp;QPushButton::clicked,this,&amp;MainWindow::close);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::eating()&#123;    //发射自定义信号    s-&gt;eat();&#125;</code></pre><p><strong>运行程序：</strong></p><p><strong>每点击一次eat按钮，回调就做一次反应</strong></p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/image-20230604222353765.png" >        </sapn>      </p><h4 id="一个信号可以对接多个槽函数"><a href="#一个信号可以对接多个槽函数" class="headerlink" title="一个信号可以对接多个槽函数"></a>一个信号可以对接多个槽函数</h4><p>一个槽函数也能接收多个信号</p><p>在mainwindow里面实现一个sleep函数，加个connect，也去相应eat按钮</p><pre><code class="cpp">MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    s=new Son;    f=new father;    connect(s,&amp;Son::eat,f,&amp;father::eatrice);    connect(s,&amp;Son::eat,this,&amp;MainWindow::sleep);    connect(ui-&gt;eating,&amp;QPushButton::clicked,this,&amp;MainWindow::eating);    connect(ui-&gt;closebt,&amp;QPushButton::clicked,this,&amp;MainWindow::close);&#125;void MainWindow::sleep()&#123;    qDebug()&lt;&lt;&quot;快去睡觉.&quot;;&#125;</code></pre><p>点击窗口，新的槽函数也去相应处理</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/QT%E4%BF%A1%E5%8F%B7%E6%A7%BD/image-20230604223746974.png" >        </sapn>      </p><p>信号也能连接信号，相当于传递了数据</p><p>对上面做如下改动：</p><pre><code class="cpp">MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    s=new Son;    f=new father;    connect(s,&amp;Son::eat,f,&amp;father::eatrice);    connect(s,&amp;Son::eat,this,&amp;MainWindow::sleep);            //这样直接用信号，相当于下面我们自己实现的发信号的函数就可以不用了    connect(ui-&gt;eating,&amp;QPushButton::clicked,s,&amp;Son::eat);        //connect(ui-&gt;eating,&amp;QPushButton::clicked,this,&amp;MainWindow::eating);    connect(ui-&gt;closebt,&amp;QPushButton::clicked,this,&amp;MainWindow::close);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;/*void MainWindow::eating()&#123;    //发射自定义信号    s-&gt;eat();&#125;*/void MainWindow::sleep()&#123;    qDebug()&lt;&lt;&quot;快去睡觉.&quot;;&#125;</code></pre><p>程序运行结果和上面一样</p><p><strong>信号槽是可以断开的</strong></p><pre><code class="cpp">disconnect(const QObject *sender, &amp;QObject::signal,         const QObject *receiver, &amp;QObject::method);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QTimer定时器,窗口界面操作</title>
      <link href="/2023/06/03/Qt-window/"/>
      <url>/2023/06/03/Qt-window/</url>
      
        <content type="html"><![CDATA[<h2 id="QTimer定时器，窗口界面操作"><a href="#QTimer定时器，窗口界面操作" class="headerlink" title="QTimer定时器，窗口界面操作"></a>QTimer定时器，窗口界面操作</h2><p><strong>本系列为跟随大丙老师博客学习笔记</strong></p><p><strong>总结代码路径：</strong><a href="https://github.com/Xw-oorik/Qt-1">Xw-oorik&#x2F;Qt-1: Qt自学 第一部分总结 (github.com)</a></p><h3 id="QTimer-定时器"><a href="#QTimer-定时器" class="headerlink" title="QTimer 定时器"></a>QTimer 定时器</h3><blockquote><pre><code class="cpp">// 构造函数// 如果指定了父对象, 创建的堆内存可以自动析构QTimer::QTimer(QObject *parent = nullptr);// 设置定时器时间间隔为 msec 毫秒// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发void QTimer::setInterval(int msec);// 获取定时器的时间间隔, 返回值单位: 毫秒int QTimer::interval() const;// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔[slot] void QTimer::start();// 启动或重新启动定时器，超时间隔为msec毫秒。[slot] void QTimer::start(int msec);// 停止定时器。[slot] void QTimer::stop();// 设置定时器精度/*参数:     - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右*/void QTimer::setTimerType(Qt::TimerType atype);Qt::TimerType QTimer::timerType() const;// 获取当前定时器的精度// 如果定时器正在运行，返回true; 否则返回false。bool QTimer::isActive() const;// 判断定时器是否只触发一次bool QTimer::isSingleShot() const;// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为falsevoid QTimer::setSingleShot(bool singleShot);</code></pre></blockquote><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605205140768.png" >        </sapn>      </p><p>mianwindow.cpp</p><pre><code class="cpp">#include&lt;QTime&gt;#include&lt;QTimer&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    //创建定时器对象    QTimer *tt=new QTimer(this);    //设置精度    tt-&gt;setTimerType(Qt::PreciseTimer);    //按钮点击事件，周期性获得当前时间    connect(ui-&gt;startBtn,&amp;QPushButton::clicked,this,[=]()    &#123;        //启动定时器        if(tt-&gt;isActive())//如果是启动的状态        &#123;            tt-&gt;stop();  //关闭 ，设为开始            ui-&gt;startBtn-&gt;setText(&quot;开始&quot;);        &#125;        else&#123;            ui-&gt;startBtn-&gt;setText(&quot;关闭&quot;);            tt-&gt;start(1000);//1s        &#125;    &#125;);    connect(tt,&amp;QTimer::timeout,this,[=]()    &#123;       //获得当前时间        QTime tm=QTime::currentTime();        QString str=tm.toString(&quot;hh:mm::ss.zzz&quot;);        ui-&gt;labshow-&gt;setText(str);    &#125;);&#125;</code></pre><h3 id="窗口练习"><a href="#窗口练习" class="headerlink" title="窗口练习"></a>窗口练习</h3><pre><code class="cpp">    setMaximumSize(600,600);    setMinimumSize(300,300);//没有设置固定大小，这样的话就能随意放缩    setWindowTitle(&quot;hello hexo&quot;);//标题    setWindowIcon(QIcon(&quot;F:\\PotBa\\public\\favicon2.ico&quot;));//图标</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605213102594.png" >        </sapn>      </p><p>ui空间快速写槽函数</p><p>鼠标右键点击 转到槽</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605213514978.png" >        </sapn>      </p><p>选择要发出的信号，确定，他会自动给你生成一个槽函数</p><pre><code class="cpp">void MainWindow::on_yd_clicked()&#123;    &#125;</code></pre><p><strong>实现一个功能</strong></p><p>我们点击移动窗口，窗口根据我们设定的值偏移，获取当前位置信息打印，修改窗口位置和尺寸信息按钮，点击随机生成新位置，窗口自动移动到新位置</p><p>注意这里我们把主窗口设置大小的函数注释掉了，这样才能让他整个屏幕跑，不去限制他的大小和位置</p><pre><code class="cpp">void MainWindow::on_yd_clicked()&#123;    //获取当前窗口位置    QRect rect=this-&gt;frameGeometry();    //移动 从当前窗口位置左上角 向右下移动    move(rect.topLeft()+QPoint(rand()%50,rand()%30));&#125;void MainWindow::on_yd1_clicked()&#123;    QRect rect=this-&gt;frameGeometry();    qDebug()&lt;&lt;&quot;左上角：&quot;&lt;&lt;rect.topLeft()           &lt;&lt;&quot;右上角：&quot;&lt;&lt;rect.topRight()             &lt;&lt;&quot;左下角：&quot;&lt;&lt;rect.bottomLeft()               &lt;&lt;&quot;右下角：&quot;&lt;&lt;rect.bottomRight()                 &lt;&lt;&quot;宽度：&quot;&lt;&lt;rect.width()                   &lt;&lt;&quot;高度：&quot;&lt;&lt;rect.height();&#125;void MainWindow::on_yd2_clicked()&#123;    int x=100+rand()%500;    int y=100+rand()%500;    int width=this-&gt;width()+50;    int height=this-&gt;height()+30;    setGeometry(x,y,width,height);&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605215200211.png" >        </sapn>      </p><pre><code class="c">我移动了几次    左上角： QPoint(939,238) 右上角： QPoint(1890,238) 左下角： QPoint(939,966) 右下角： QPoint(1890,966) 宽度： 952 高度： 729    左上角： QPoint(112,283) 右上角： QPoint(1113,283) 左下角： QPoint(112,1041) 右下角： QPoint(1113,1041) 宽度： 1002 高度： 759</code></pre><p>下面添加个功能，点击按钮重新设置一下窗口的标题和图标</p><pre><code class="cpp">void MainWindow::on_rebuild_clicked()  //重新设置标题和图标&#123;    this-&gt;setWindowIcon(QIcon(&quot;F:\\PotBa\\public\\favicon1.ico&quot;));    this-&gt;setWindowTitle(&quot;新标题&quot;);&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605220043779.png" >        </sapn>      </p><p>在mainwindow构造函数添加个connect响应的打印信息，当按钮被按下，信号发出，槽函数接收到信号做替换标题和图标的处理，当图标&#x2F;标题被修改了，发出俩信号windowTitleChanged和windowIconChanged，我们去写个匿名的槽函数去接收这俩信号然后做个打印</p><pre><code class="cpp">        connect(this,&amp;MainWindow::windowTitleChanged,this,[=](const QString &amp;title )    &#123;        qDebug()&lt;&lt;&quot;新的标题是:&quot;&lt;&lt;title;    &#125;);    connect(this,&amp;MainWindow::windowIconChanged,this,[=](const QIcon &amp;icon )    &#123;        qDebug()&lt;&lt;&quot;新的图标是:&quot;&lt;&lt;icon;    &#125;);</code></pre><p><strong>添加新功能，我们增加鼠标右键菜单。默认我们对窗口右键是没反应的</strong></p><pre><code class="cpp">    //设置右键菜单策略    setContextMenuPolicy(Qt::CustomContextMenu);    connect(this,&amp;MainWindow::customContextMenuRequested,this,[=](const QPoint&amp; p)&#123;        //创建一个空菜单        QMenu menu;        menu.addAction(&quot;点餐&quot;);        menu.addAction(&quot;住宿&quot;);        menu.addAction(&quot;游玩&quot;);        menu.exec(QCursor::pos());//鼠标右键点击的坐标位置，相对于系统屏幕的，而不是当前窗口            &#125;);</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605222153208.png" >        </sapn>      </p><p>上面的一些操作都是QWidget这个父类的，虽然用的mainwindow，但是是mainwindow继承QWidget他这个类的，所以操作api也是能用的，所以上面的示例api都是QWidget本身的</p><p>对于三个窗口关系，可以去看我Qt第一讲 -&gt;移步主页csdn链接</p><p>下面说QDialog一些操作，他特有操作对于QWidget肯定就用不了了，父子继承明白吧</p><h3 id="QDialog对话框"><a href="#QDialog对话框" class="headerlink" title="QDialog对话框"></a>QDialog对话框</h3><p>QDialog类里面上面那些操作也是能用的</p><p>下面对于他特有的api去操作，上面的案例</p><p>dialog里面的accept，reject，done</p><pre><code class="cpp">// 模态显示窗口[virtual slot] int QDialog::exec();// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted[virtual slot] void QDialog::accept();// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected[virtual slot] void QDialog::reject();// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。[virtual slot] void QDialog::done(int r);发射信号[signal] void QDialog::accepted();[signal] void QDialog::rejected();[signal] void QDialog::finished(int result);</code></pre><p>创建一个dialog类，创建三个按钮</p><p>在dialog.cpp创建槽函数</p><pre><code class="cpp">void MyDialog::on_ac_clicked()&#123;    //结束模态对话框的阻塞，隐藏    this-&gt;accept();&#125;void MyDialog::on_re_clicked()&#123;    this-&gt;reject();&#125;void MyDialog::on_do_2_clicked()&#123;    this-&gt;done(10); //自定义的返回值&#125;</code></pre><p>在mainwindow里面加一个按钮显示调用 模态的dialog对话框</p><pre><code class="cpp">void MainWindow::on_module_clicked()&#123;    MyDialog dig;    int ret=dig.exec();    if(ret==QDialog::Accepted)&#123; //返回1        qDebug()&lt;&lt;&quot;accept clicked&quot;;    &#125;    else if(ret==QDialog::Rejected)&#123; //返回0        qDebug()&lt;&lt;&quot;reject clicked&quot;;    &#125;    else&#123;        qDebug()&lt;&lt;&quot;done clicked&quot;;    &#125;&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605224505474.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605224527353.png" >        </sapn>      </p><p>对于dialog的模态非模态，模态就是当前窗口点开了，就不能操作别的窗口了，点击别的地方会发出那种声响你懂吧，非模态就是随便操作咯</p><p>我们加个打印去接收一下这三个信号，看看返回值</p><p>修改一下槽函数，看下打印：</p><pre><code class="cpp">void MainWindow::on_module_clicked()&#123;    MyDialog dig;    connect(&amp;dig,&amp;MyDialog::finished,this,[=](int res)&#123;        qDebug()&lt;&lt;&quot;finished: &quot;&lt;&lt;res;    &#125;);    connect(&amp;dig,&amp;MyDialog::accepted,this,[=]()&#123;        qDebug()&lt;&lt;&quot;accept 发射--: &quot;;    &#125;);    connect(&amp;dig,&amp;MyDialog::rejected,this,[=]()&#123;        qDebug()&lt;&lt;&quot;rejected 发射--:&quot; ;    &#125;);    int ret=dig.exec();    if(ret==QDialog::Accepted)&#123; //返回1        qDebug()&lt;&lt;&quot;accept clicked&quot;;    &#125;    else if(ret==QDialog::Rejected)&#123; //返回0        qDebug()&lt;&lt;&quot;reject clicked&quot;;    &#125;    else&#123;        qDebug()&lt;&lt;&quot;done clicked&quot;;    &#125;&#125;</code></pre><p>我三个按钮都点了一下，效果如下，accept果然返回的是1，reject返回0，done返回我们自定义</p><p>finished就是去对应发出三个的信号，且能接收参数的</p><p>而accepted和rejected只是对应accept和reject的，且不带参数</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230605230055771.png" >        </sapn>      </p><h3 id="看QDialog子类"><a href="#看QDialog子类" class="headerlink" title="看QDialog子类"></a>看QDialog子类</h3><h4 id="QMessageBox-消息提示框"><a href="#QMessageBox-消息提示框" class="headerlink" title="QMessageBox 消息提示框"></a>QMessageBox 消息提示框</h4><p>在mainwindow加一个控件，实现对应槽函数，应用QMessageBox 类的api，就有如下效果</p><pre><code class="cpp">void MainWindow::on_msgbox_clicked()&#123;    QMessageBox::about(this,&quot;about&quot;,&quot;这是一个简单的测试消息提示框！&quot;);    QMessageBox::critical(this,&quot;critical&quot;,&quot;这是一个测试错误对话框!&quot;);    int ret=QMessageBox::question(this,&quot;question&quot;,&quot;你要保存修改的内容吗？？&quot;,                                  QMessageBox::Save|QMessageBox::Cancel,                                  QMessageBox::Cancel);    if(ret==QMessageBox::Save)    &#123;        QMessageBox::information(this,&quot;information&quot;,&quot;恭喜保存成功！&quot;);    &#125;    else if(ret==QMessageBox::Cancel)    &#123;        QMessageBox::warning(this, &quot;warning&quot;, &quot;你放弃了保存, ┭┮﹏┭┮ !!!&quot;);    &#125;&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606000430414.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606000436448.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606000449122.png" >        </sapn>      </p><h4 id="QFileDialog"><a href="#QFileDialog" class="headerlink" title="QFileDialog"></a>QFileDialog</h4><p>QFileDialog 对话框类是 QDialog 类的子类，<strong>通过这个类可以选择要打开 &#x2F; 保存的文件或者目录</strong>。关于这个类我们只需要掌握一些静态方法的使用就可以了。</p><p>添加新功能： &#x2F;&#x2F;打开多个文件  &#x2F;&#x2F;打开保存文件对话框</p><p>当然这里实现保存文件，肯定是没有未保存的，这里只是做gui的演示，具体文件操作就需要open，write那些c++&#x2F;c的api去操作文件了，就是后端逻辑</p><pre><code class="cpp">void MainWindow::on_mulu_clicked()&#123;#if 0    QString arg(&quot;Text files(*.txt *.md&quot;);//指定以这个格式过滤,意思只显示这两种类型文件    //打开多个文件，得到文件的绝对路径    QStringList filenames=QFileDialog::getOpenFileNames(                this,&quot;open files&quot;,&quot;F:\\&quot;,                &quot;Images(*.png *.jpg);;Text files(*.txt *.md)&quot;,                &amp;arg);  //指定了多个过滤器，默认是第一个。我这里手动指定是.txt *.md的    QString names;    for(auto x:filenames)    &#123;        names+=x+&quot;%%%&quot;;    &#125;    //以QMessageBox提示框显示     QMessageBox::information(this,&quot;打开文件(s)&quot;,&quot;您选择的文件是: &quot;+names);#else    QString filename=QFileDialog::getSaveFileName(this,&quot;保存文件&quot;,&quot;F:\\PotBa&quot;);    QMessageBox::information(this,&quot;保存文件成功！&quot;,&quot;保存的文件是:&quot;+filename);#endif&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606202621889.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606202706824.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606202714382.png" >        </sapn>      </p><p>并没有替换成功，只是界面展示这样</p><h4 id="QFontDialog"><a href="#QFontDialog" class="headerlink" title="QFontDialog"></a>QFontDialog</h4><p>根据这个对话框类，拿到一个设置字体的对话框（字体，大小，等等）</p><p>我们只需要调用这个类的静态成员函数就可以得到想要的窗口了。</p><p><strong>关于设置字体属性的我们需要借助QFont这个类</strong></p><pre><code class="cpp">// 构造函数  QFont::QFont();  /*  参数:    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看    - pointSize: 字体的字号    - weight: 字体的粗细, 有效范围为 0 ~ 99    - italic: 字体是否倾斜显示, 默认不倾斜  */  QFont::QFont(const QString &amp;family, int pointSize = -1, int weight = -1, bool italic = false);    // 设置字体  void QFont::setFamily(const QString &amp;family);  // 根据字号设置字体大小  void QFont::setPointSize(int pointSize);  // 根据像素设置字体大小  void QFont::setPixelSize(int pixelSize);  // 设置字体的粗细程度, 有效范围: 0 ~ 99  void QFont::setWeight(int weight);  // 设置字体是否加粗显示  void QFont::setBold(bool enable);  // 设置字体是否要倾斜显示  void QFont::setItalic(bool enable);    // 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)  QString QFont::family() const;  bool QFont::italic() const;  int QFont::pixelSize() const;  int QFont::pointSize() const;  bool QFont::bold() const;  int QFont::weight() const;/*参数:  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化  - parent: 字体对话框窗口的父对象  - title: 字体对话框的窗口标题  - options: 字体对话框选项, 使用默认属性即可, 一般不设置*/  [static] QFont QFontDialog::getFont(        bool *ok, const QFont &amp;initial,         QWidget *parent = nullptr, const QString &amp;title = QString(),         QFontDialog::FontDialogOptions options = FontDialogOptions());    [static] QFont QFontDialog::getFont(bool *ok, QWidget *parent = nullptr);// QWidget 类// 得到当前窗口使用的字体const QWidget::QFont&amp; font() const;// 给当前窗口设置字体, 只对当前窗口类生效void QWidget::setFont(const QFont &amp;);// QApplication 类// 得到当前应用程序对象使用的字体[static] QFont QApplication::font();// 给当前应用程序对象设置字体, 作用于当前应用程序的所有窗口[static] void QApplication::setFont(const QFont &amp;font, const char *className = nullptr);</code></pre><p><strong>添加新功能：</strong></p><p>我们点击设置字体，选择完成后，更改下方标签hello word！！！字体，并且改变所有窗口的字体设置</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606204515765.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606205300941.png" >        </sapn>      </p><p>设置，标签测试+整个窗口字体</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606205437956.png" >        </sapn>      </p><pre><code class="cpp">void MainWindow::on_font_clicked()&#123;    bool ok;    bool is=true;                                                 //默认不倾斜，这里设置倾斜 true    QFont font=QFontDialog::getFont(&amp;ok,QFont(&quot;微软雅黑&quot;,12,QFont::Bold,is),this,&quot;选择字体&quot;);    qDebug()&lt;&lt;&quot; ok is : &quot;&lt;&lt;ok;        //作用到全部窗口 和label标签    ui-&gt;fontlabel-&gt;setFont(font);    QApplication::setFont(font, nullptr);//默认&#125;</code></pre><h4 id="QColorDialog"><a href="#QColorDialog" class="headerlink" title="QColorDialog"></a>QColorDialog</h4><p>颜色对话框类，配置颜色用 QColor</p><p>使用和设置字体基本大差不差</p><pre><code class="cpp">void MainWindow::on_colorbt_clicked()&#123;    QColor col=QColorDialog::getColor();    //绘图操作    QBrush brush(col);    QRect rect(0,0,ui-&gt;colorshow-&gt;width(),ui-&gt;colorshow-&gt;height());    QPixmap pix(rect.width(), rect.height());    QPainter p(&amp;pix);    p.fillRect(rect, brush);    ui-&gt;colorshow-&gt;setPixmap(pix);    QString text = QString(&quot;red: %1, green: %2, blue: %3, 透明度: %4&quot;)               .arg(col.red()).arg(col.green()).arg(col.blue()).arg(col.alpha());    ui-&gt;colorpt-&gt;setText(text);&#125;</code></pre><p><strong>代码解释如下:</strong></p><p>这段代码是一个槽函数，当用户点击名为<code>colorbt</code>的按钮时，就会执行这个函数。这个函数的作用是打开一个颜色选择对话框，然后根据用户选择的颜色在名为<code>colorshow</code>的窗口部件上填充颜色，并在名为<code>colorpt</code>的标签上显示选择的颜色的RGB值和透明度。</p><p>首先，<code>QColorDialog::getColor()</code>函数用于打开一个颜色选择对话框，让用户选择颜色。这个函数会返回一个<code>QColor</code>对象，表示用户选择的颜色。</p><p>然后，根据用户选择的颜色创建一个<code>QBrush</code>对象<code>brush</code>，并创建一个与<code>colorshow</code>窗口部件大小相同的矩形区域<code>rect</code>，用于在后续的绘图操作中指定绘图区域。接着，创建一个<code>QPixmap</code>对象<code>pix</code>，表示一个像素图，大小与<code>rect</code>相同。</p><p>使用<code>QPainter</code>对象<code>p</code>在<code>pix</code>上进行绘图操作，使用<code>fillRect</code>函数在<code>rect</code>矩形区域内填充颜色，颜色由<code>brush</code>指定。最后，使用<code>ui-&gt;colorshow-&gt;setPixmap(pix)</code>将绘制好的<code>pix</code>像素图设置为<code>colorshow</code>窗口部件的显示内容，从而实现在<code>colorshow</code>窗口部件上填充用户选择的颜色的效果。</p><p>最后，使用<code>QString</code>类的<code>arg</code>函数将颜色的RGB值和透明度格式化成一个字符串，并将其设置为<code>colorpt</code>标签的文本内容，从而在<code>colorpt</code>标签上显示用户选择的颜色的RGB值和透明度。</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606211930864.png" >        </sapn>      </p><p><strong>点击设置颜色</strong></p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606211950340.png" >        </sapn>      </p><p><strong>设置完成</strong></p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606212021843.png" >        </sapn>      </p><h4 id="QInputDialog"><a href="#QInputDialog" class="headerlink" title="QInputDialog"></a>QInputDialog</h4><p>这是一个输入对话框窗口</p><pre><code class="cpp">// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数/*参数:  - parent: 对话框窗口的父窗口  - title: 对话框窗口显示的标题信息  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)  - value: 对话框窗口中显示的浮点值, 默认为 0  - min: 对话框窗口支持显示的最小数值  - max: 对话框窗口支持显示的最大数值  - decimals: 浮点数的精度, 默认保留小数点以后1位  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数  - flags: 对话框窗口的窗口属性, 使用默认值即可*/[static] double QInputDialog::getDouble(            QWidget *parent, const QString &amp;title,             const QString &amp;label, double value = 0,             double min = -2147483647, double max = 2147483647,             int decimals = 1, bool *ok = nullptr,             Qt::WindowFlags flags = Qt::WindowFlags());// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数/*参数:  - parent: 对话框窗口的父窗口  - title: 对话框窗口显示的标题信息  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)  - value: 对话框窗口中显示的整形值, 默认为 0  - min: 对话框窗口支持显示的最小数值  - max: 对话框窗口支持显示的最大数值  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数  - flags: 对话框窗口的窗口属性, 使用默认值即可*/[static] int QInputDialog::getInt(            QWidget *parent, const QString &amp;title,             const QString &amp;label, int value = 0,             int min = -2147483647, int max = 2147483647,             int step = 1, bool *ok = nullptr,             Qt::WindowFlags flags = Qt::WindowFlags());// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息/*参数:  - parent: 对话框窗口的父窗口  - title: 对话框窗口显示的标题信息  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数  - flags: 对话框窗口的窗口属性, 使用默认值即可  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串    - 如果有特殊需求, 可以参数帮助文档进行相关设置*/[static] QString QInputDialog::getItem(            QWidget *parent, const QString &amp;title,             const QString &amp;label, const QStringList &amp;items,             int current = 0, bool editable = true, bool *ok = nullptr,             Qt::WindowFlags flags = Qt::WindowFlags(),             Qt::InputMethodHints inputMethodHints = Qt::ImhNone);// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息/*参数:  - parent: 对话框窗口的父窗口  - title: 对话框窗口显示的标题信息  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数  - flags: 对话框窗口的窗口属性, 使用默认值即可  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串    - 如果有特殊需求, 可以参数帮助文档进行相关设置*/[static] QString QInputDialog::getMultiLineText(            QWidget *parent, const QString &amp;title, const QString &amp;label,             const QString &amp;text = QString(), bool *ok = nullptr,             Qt::WindowFlags flags = Qt::WindowFlags(),             Qt::InputMethodHints inputMethodHints = Qt::ImhNone);// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息/*参数:  - parent: 对话框窗口的父窗口   - title: 对话框窗口显示的标题信息  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值    - QLineEdit::Normal: 显示输入的字符。这是默认值    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数  - flags: 对话框窗口的窗口属性, 使用默认值即可  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串     - 如果有特殊需求, 可以参数帮助文档进行相关设置*/[static] QString QInputDialog::getText(            QWidget *parent, const QString &amp;title, const QString &amp;label,            QLineEdit::EchoMode mode = QLineEdit::Normal,             const QString &amp;text = QString(), bool *ok = nullptr,             Qt::WindowFlags flags = Qt::WindowFlags(),             Qt::InputMethodHints inputMethodHints = Qt::ImhNone);</code></pre><p><strong>添加新功能：滚动设置，写一个下拉选择框，设置密码（一行文本编辑），多行文本编辑</strong></p><p>也都是调用静态函数，如下案例代码：</p><pre><code class="cpp">#define LINEvoid MainWindow::on_chat_clicked()&#123;#ifdef INT    int res=QInputDialog::getInt(this,&quot;设置年龄&quot;,&quot;年龄:&quot;,0,0,100,1);    QMessageBox::information(this,&quot;成功！&quot;,&quot;年龄设置为:&quot;+QString::number(res));#endif#ifdef ITEM    QStringList  list;    list&lt;&lt;&quot;麻婆豆腐&quot;&lt;&lt;&quot;红烧肉&quot;&lt;&lt;&quot;锅包肉&quot;;    QString str=QInputDialog::getItem(this,&quot;菜单&quot;,&quot;选择菜品:&quot;,list,1,true);    QMessageBox::information(this,&quot;点菜成功！&quot;,&quot;点的菜为:&quot;+str);#endif#ifdef TEXT                                              //默认设置是123456密码    QString text = QInputDialog::getText(this, &quot;密码&quot;, &quot;请输入新的密码&quot;, QLineEdit::Password, &quot;123456&quot;);    QMessageBox::information(this, &quot;密码&quot;, &quot;您设置的密码是: &quot; + text);#endif#ifdef LINE    QString ss=QInputDialog::getMultiLineText(this,&quot;漂流瓶&quot;,&quot;写给30年后的自己&quot;,&quot;你好,30年后的xxx:&quot;);    QMessageBox::information(this, &quot;漂流瓶&quot;, &quot;您对30年后的自己写的话是: &quot; + ss);#endif&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606214646189.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606215321602.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606215615293.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606220104563.png" >        </sapn>      </p><h4 id="QProgressDialog"><a href="#QProgressDialog" class="headerlink" title="QProgressDialog"></a>QProgressDialog</h4><p>进度条对话框窗口类</p><p>新添功能：实现一个模拟下载的进度框，为模态的窗口，当取消下载后，当前窗口关闭，对象析构，而不需要等着父对象析构他再析构</p><pre><code class="cpp">void MainWindow::on_download_clicked()&#123;        //创建进度条对话框窗口对象        QProgressDialog *pro=new QProgressDialog(&quot;正在下载..&quot;,&quot;取消下载&quot;,0,100,this);        //初始化显示进度条窗口        pro-&gt;setWindowTitle(&quot;请稍等..&quot;);        pro-&gt;setWindowModality(Qt::WindowModal);//模态        pro-&gt;show();        //更新进度条，利用定时器演示        static int value=0;        QTimer *timer =new QTimer();        connect(timer,&amp;QTimer::timeout,this,[=]()&#123;           pro-&gt;setValue(value);           value++;           if(value&gt;pro-&gt;maximum())           &#123;               //关掉定时器               timer-&gt;stop();               value=0;               //手动去析构对象               delete pro;               delete timer;           &#125;        &#125;);        //点击取消下载，接收到信号，析构对象        connect(pro,&amp;QProgressDialog::canceled,this,[=]()&#123;           timer-&gt;stop();           value=0;           delete pro;           delete timer;        &#125;);        timer-&gt;start(50);//50毫秒更新一次&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230606224819514.png" >        </sapn>      </p><h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h3><p><strong>QMainWindow 是标准基础窗口中结构最复杂的窗口，其组成如下:</strong></p><ol><li>提供了菜单栏 , 工具栏 , 状态栏 , 停靠窗口</li><li>菜单栏：只能有一个，位于窗口的最上方</li><li>工具栏：可以有多个，默认提供了一个，窗口的上下左右都可以停靠</li><li>状态栏：只能有一个，位于窗口最下方</li><li>停靠窗口：可以有多个，默认没有提供，窗口的上下左右都可以停靠</li></ol><h4 id="演示菜单栏"><a href="#演示菜单栏" class="headerlink" title="演示菜单栏"></a>演示菜单栏</h4><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607210745882.png" >        </sapn>      </p><p>菜单项默认不能输入中文，想要输入中文需要新建菜单栏</p><p>点击名称上面那个单文件式按钮</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607210947537.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607211241338.png" >        </sapn>      </p><p>拖动到菜单栏，这个菜单项就会自动添加</p><p>        <span class="lazyload-img-span">        <img              data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230607211307289.png" >        </sapn>      </p><p>在mainwindow构造函数添加对应槽函数,与连接</p><pre><code class="cpp">    //相映菜单项点击后信号    connect(ui-&gt;openaction,&amp;QAction::triggered,this,[=]()&#123;        QMessageBox::information(this,&quot;clicked&quot;,&quot;新建成功&quot;);    &#125;);    connect(ui-&gt;actionopen,&amp;QAction::triggered,this,[=]()&#123;        QMessageBox::information(this,&quot;clicked&quot;,&quot;打开成功&quot;);    &#125;);    connect(ui-&gt;actionclose,&amp;QAction::triggered,this,[=]()&#123;        QMessageBox::information(this,&quot;clicked&quot;,&quot;关闭成功&quot;);    &#125;);</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607211843966.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607211852257.png" >        </sapn>      </p><h4 id="演示工具栏"><a href="#演示工具栏" class="headerlink" title="演示工具栏"></a>演示工具栏</h4><p>添加工具栏，tooBar</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607212218674.png" >        </sapn>      </p><p>给工具栏里面添加控件，我们可以直接在ui界面里面创建，然后跟上面一样拖上去就行</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607212637980.png" >        </sapn>      </p><p>也可以使用代码去添加控件</p><p>给mainwindow构造函数中添加</p><pre><code class="cpp">    //给工具栏添加按钮和单行输入框    ui-&gt;toolBar-&gt;addWidget(new QPushButton(&quot;搜索&quot;));    ui-&gt;toolBar-&gt;addWidget(new QLineEdit);</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607212911747.png" >        </sapn>      </p><p>对于工具栏，我们可以在ui界面找到工具栏对象，可以做一些设置</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607213630032.png" >        </sapn>      </p><p>比如movable打钩，这个工具栏就能随意拖动停靠</p><p>效果如下：</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607213825946.png" >        </sapn>      </p><p><strong>通过代码去添加工具栏</strong></p><p>在mainwindow构造函数中添加</p><pre><code class="cpp">    //添加新的一个工具栏    QToolBar* toolbar=new QToolBar(&quot;toolbar2&quot;);    this-&gt;addToolBar(Qt::LeftToolBarArea,toolbar);</code></pre><h4 id="演示状态栏"><a href="#演示状态栏" class="headerlink" title="演示状态栏"></a>演示状态栏</h4><p>状态栏只能有一个，QStatusBar</p><p>给状态栏添加一些控件</p><pre><code class="cpp">    //给状态栏添加控件    ui-&gt;statusbar-&gt;showMessage(&quot;我是状态栏.&quot;,4000); //显示4秒，自动清除    QPushButton* button=new QPushButton(&quot;当前行&quot;);    ui-&gt;statusbar-&gt;addWidget(button);    QLabel *label=new QLabel(&quot;1&quot;);    ui-&gt;statusbar-&gt;addWidget(label);    QTimer::singleShot(5000,this,[=]()&#123;        button-&gt;show();        label-&gt;show();  //显示出来,showMessage清除后，被覆盖的控件是不会显示的，要手动调用显示    &#125;);</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607230027766.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607230038578.png" >        </sapn>      </p><h4 id="停靠窗口"><a href="#停靠窗口" class="headerlink" title="停靠窗口"></a>停靠窗口</h4><p>停靠窗口可以通过鼠标拖动停靠到窗口的上、下、左、右，或者浮动在窗口上方。如果需要这种类型的窗口必须手动添加，如果在非QMainWindow类型的窗口中添加了停靠窗口, 那么这个窗口是不能移动和浮动的。<br>浮动窗口在工具栏中， 直接将其拖拽到 UI 界面上即可。</p><p>右下角可以设置一些属性</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230607233603728.png" >        </sapn>      </p><h3 id="资源文件-qrc"><a href="#资源文件-qrc" class="headerlink" title="资源文件 .qrc"></a>资源文件 .qrc</h3><p>把exe需要加载的资源，加载到一个文件中</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230608001915498.png" >        </sapn>      </p><p>add prefix 是我们要添加的资源在资源文件中的路径 ，add files添加资源文件，注意资源文件在pro位置同级或者更深，路径，名称最好不要带中文</p><p>&#x2F;…&#x2F;…</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230608002047608.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/Qt-window/image-20230608002848938.png" >        </sapn>      </p><p>以后把要用到的文件搞成一个资源文件夹，代码里资源路径就用资源文件夹里的，这样打包成exe之后，这些资源都是可使用的</p>]]></content>
      
      
      <categories>
          
          <category> Qt学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>curl和libcurl</title>
      <link href="/2023/05/26/libcurl1/"/>
      <url>/2023/05/26/libcurl1/</url>
      
        <content type="html"><![CDATA[<h1 id="curl-libcurl简化你的网络请求！"><a href="#curl-libcurl简化你的网络请求！" class="headerlink" title="curl+libcurl简化你的网络请求！"></a>curl+libcurl简化你的网络请求！</h1><p>curl 是一个linux工具，通过命令行来实现其强大的功能。但通过libcurl，可以在各种开发环境中通过编码的 形式实现curl上传、下载功能，其中涉及GET、PUT、POST、DELETE等方法。cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。可谓是支持力度相当大的一个工具了。</p><h3 id="curl命令行工具：Linux-Curl命令详解教程-myfreax"><a href="#curl命令行工具：Linux-Curl命令详解教程-myfreax" class="headerlink" title="curl命令行工具：Linux Curl命令详解教程 | myfreax"></a>curl命令行工具：<a href="https://www.myfreax.com/curl-command-examples/">Linux Curl命令详解教程 | myfreax</a></h3><p><a href="https://blog.csdn.net/u013514928/article/details/102810250"> curl命令用法_curl 命令_追梦菜鸟的博客-CSDN博客</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/09/curl.html">curl网站开发指南 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>curl -o 文件名 网址 可以把对应网页保存下来到文件里</p><p>-o 保存成文件</p><p>-F是用来传二进制文件的 curl -F ‘xx文件’ 地址&#x2F;发post请求传表单数据，上面实现就是用到这个参数</p><p>-H 用来加http请求头的</p><p>做断点续传可以用-C去恢复上次的传输进度</p><h2 id="libcurl库学习"><a href="#libcurl库学习" class="headerlink" title="libcurl库学习"></a>libcurl库学习</h2><p><a href="https://www.cnblogs.com/heluan/p/10177475.html#:~:text=(%E8%BD%AC)libcu,%EF%BC%8C%E5%A5%BD%E9%95%BF%EF%BC%8C%E5%A5%BD%E8%AF%A6%E7%BB%86%E3%80%82">(转)libcurl库使用方法，好长，好详细。 - _浪潮之巅.☆ - 博客园 (cnblogs.com)</a>  感觉光看这个就非常的详细了</p><p><a href="https://blog.csdn.net/weixin_43608153/article/details/90811132"> curl 简单实例 （c代码通过 curl-url 实现信息获取）_curl c_我若成精的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zengraoli/article/details/11580167">Libcurl使用入门教程_libcurl c++ example_每天看一遍，防止恋爱&amp;&amp;堕落的博客-CSDN博客</a></p><p>可以用libcurl库函数去操作完成curl命令</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;curl/curl.h&gt;int main() &#123;    CURL *curl;    CURLcode res;    char *url = &quot;http://www.baidu.com&quot;;    curl = curl_easy_init();    if(curl) &#123;        curl_easy_setopt(curl, CURLOPT_URL, url);        res = curl_easy_perform(curl);        if(res == CURLE_OK)            printf(&quot;Request succeeded!\n&quot;);        else            printf(&quot;Request failed: %s\n&quot;, curl_easy_strerror(res));        curl_easy_cleanup(curl);    &#125;    printf(&quot;over!\n&quot;);    return 0;&#125;</code></pre><p>gcc -o main pp.c -lcurl编译</p><p>使用最开始要初始化libcurl，可以用curl_global_init做全局配置他只能调用一次，自己不调用的话系统在curl_easy_init()前会自动调用，（多线程会有问题，最好手动调）这个demo是使用<code>curl_easy_init()</code>函数初始化libcurl库，并使用<code>curl_easy_setopt()</code>函数设置要执行的URL。发起http get请求获取相应的请求状态，用<code>curl_easy_perform()</code>函数执行实际的请求，并返回状态码。最后，<code>curl_easy_cleanup()</code>函数释放curl库。</p><p>用libcurl做sftp去传东西，有关密码的也能用cur_easy_setopt这个flag:CURLOPT_USERPWD去做密码，私钥可以用CURLOPT_KEYPASSWD去设置</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python总结</title>
      <link href="/2023/05/25/py%E6%80%BB%E7%BB%931/"/>
      <url>/2023/05/25/py%E6%80%BB%E7%BB%931/</url>
      
        <content type="html"><![CDATA[<h2 id="分享我最近在学习python看过的一些文章"><a href="#分享我最近在学习python看过的一些文章" class="headerlink" title="分享我最近在学习python看过的一些文章 "></a><font color='blue'>分享我最近在学习python看过的一些文章 </font></h2><p> <strong>打好基础：</strong><br> <a href="https://blog.csdn.net/colinlee19860724/category_8774106.html?spm=1001.2014.3001.5515">Python_Sir静堂的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/ityard/category_9466550.html?spm=1001.2014.3001.5515">基础_Python小二的博客-CSDN博客</a></p><p><a href="https://pythonav.com/wiki/">pythonav资源分享</a></p><p><a href="https://blog.csdn.net/m0_37717595/category_9274239.html?spm=1001.2014.3001.5515">Python学习笔记_m0_37717595的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/421726412">学习Python，这一篇管够（入门|基础|进阶|实战） - 知乎 (zhihu.com)</a>  </p><p><strong>Python面向对象设计</strong> </p><p><a href="https://blog.csdn.net/zengraoli/article/details/81319963"> 10、Python面向对象设计_python 面向对象设计结构_每天看一遍，防止恋爱&amp;&amp;堕落的博客-CSDN博客</a></p><p><strong>python多线程</strong> </p><p><a href="https://blog.csdn.net/zengraoli/article/details/81320356"> 12、Python多线程_python多线程 run重写_每天看一遍，防止恋爱&amp;&amp;堕落的博客-CSDN博客</a></p><p><strong>python多进程</strong> </p><p><a href="https://blog.csdn.net/zengraoli/article/details/81320523"> 13、Python多进程_with pool_每天看一遍，防止恋爱&amp;&amp;堕落的博客-CSDN博客</a></p><p><strong>python协程：</strong></p><p><a href="https://www.cnblogs.com/liyuanhong/articles/14268571.html">进程、线程、携程的理解（python中的async关键字） - 远洪 - 博客园 (cnblogs.com)</a></p><p><strong>python魔法函数：</strong></p><p><a href="https://blog.csdn.net/qq_46092061/article/details/120314165">【强烈推荐】超详解Python-魔法函数（高级语法）_python魔法函数_ZSYL的博客-CSDN博客</a></p><p><strong>python内部函数&#x2F;闭包&#x2F;装饰器：</strong></p><p><a href="https://www.cnblogs.com/liyuanhong/articles/12559041.html">python 装饰器、内部函数、闭包简单理解 - 远洪 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/weixin_38278993/article/details/91540213">Python 类的内置函数_类的函数内函数_lucky0han的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zengraoli/article/details/81320128"> 11、Python高级程序设计_每天看一遍，防止恋爱&amp;&amp;堕落的博客-CSDN博客</a> </p><p>**</p><p><strong>有关python自动化测试的：</strong>[Python之自动单元测试之一（TestCase的使用） - 远洪 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/liyuanhong/articles/5306918.html#:~:text=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BB%84%E6%88%90%E5%8D%95%E5%85%83%E6%98%AF">https://www.cnblogs.com/liyuanhong/articles/5306918.html#:~:text=软件测试中最基本的组成单元是</a> 测试用例,（test case），PyUnit使用TestCase类来表示测试用例，并要求所有用于执行测试的类都必须从该类继承。) </p><p><a href="https://blog.csdn.net/fengguangke/article/details/81673971"> unittest之TestCase类详解_unittest.testcase_都市小懒人的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zengraoli/article/details/104693717"> 《Python编程快速上手,让繁琐工作自动化》读书笔记_每天看一遍，防止恋爱&amp;&amp;堕落的博客-CSDN博客</a></p><p>python的自动测试框架PyUnit</p><p>unittest之TestCase类</p><p>PyUnit使用TestCase类来表示测试用例，并要求所有用于执行测试的类都必须从该类继承</p><p>如果想在每次测试前后对测试环境进行初始化和恢复，则需要重载setUp以及tearDown</p><p>每个测试函数在执行之前，都会调用一次setUp，而测试函数结束时则会调用tearDown。</p><pre><code class="python">import unittestclass AGentTestCase(unittest.TestCase):    def setUp(self):   #内置的        print(&quot;初始化&quot;)    def test_ip(self,*args,**kwargs): #自己写的测试用例        pass    def testsize(self,si):   #自己写的测试用例        pass    def testDown(self):  #内置的        print(&quot;结束清除&quot;)        if name ==&quot;main&quot;:unittest.main()            # unittest.main()函数用来测试 类中以 test 开头的测试用例</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" >        </sapn>      </p><h3 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h3><p><a href="https://www.cnblogs.com/liyuanhong/articles/12902522.html">Python之re模块 - 远洪 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux多线程</title>
      <link href="/2023/05/22/C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/05/22/C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>抽空复习总结了一下笔记</p><h2 id="元婴期"><a href="#元婴期" class="headerlink" title="元婴期"></a>元婴期</h2><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>在操作系统中，<code>.rodata</code>是数据段（Data Segment）的一个子段，它通常被用来存储只读的数据，例如字符串常量、全局常量等等。<code>.rodata</code>是英文”read-only data”的缩写，也就是只读数据的意思。</p><p>数据段是程序中用来存储静态数据和全局变量的内存区域。数据段通常被分为多个子段，每个子段存储不同类型的数据。除了<code>.rodata</code>之外，数据段还包括<code>.data</code>和<code>.bss</code>等子段。</p><ul><li><code>.data</code>子段用于存储已初始化的全局变量和静态变量。在程序加载时，<code>.data</code>子段中的数据会被拷贝到内存中的数据段中，并分配相应的内存空间。</li><li><code>.bss</code>子段用于存储未初始化的全局变量和静态变量或者初始化为0的。在程序加载时，<code>.bss</code>子段中的变量会被初始化为0，并分配相应的内存空间。由于<code>.bss</code>子段中的变量都被初始化为0，因此不需要在可执行文件中存储它们的初始值，这可以减小可执行文件的大小。</li></ul><p>因此，<code>.rodata</code>是数据段的一部分，用于存储只读的数据，例如字符串常量、全局常量等等。<code>.data</code>和<code>.bss</code>也是数据段的子段，分别用于存储已初始化和未初始化的全局变量和静态变量。</p><p><strong>由于同一进城的多个线程共享同一地址空间</strong>，因此text段，data段都是共享的，如果定义一个函数，在各个线程中都可以调用，如果定义一个全局变量，在各个线程中都可以访问到，除此以下也是共享的</p><ol><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户id和组id</li><li>堆空间（因为共享进程地址空间）</li></ol><p><strong>不共享的：</strong></p><ol><li>线程id</li><li>上下文，包括各种寄存器的值，程序计数器，栈指针</li><li>栈空间</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ol><p>之前不知道这个：<strong>一个线程可以调用pthread_cancel终止同一进程中的另一个线程</strong></p><p>pthread_create 传的函数类型是 void* (<em>)(void</em>)，即函数应该接收一个void<em>参数，返回一个void</em>指针</p><p>pthread_self拿到线程id</p><p>锁都是共享，创建的话就放在全局</p><pre><code class="c">pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex,NULL);</code></pre><p><strong>有关挂起等待，唤醒等待线程的操作</strong></p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230531002013340.png" >        </sapn>      </p><p>在 pthread 头文件中，定义了一些宏（宏定义）来简化互斥锁和条件变量的初始化。这些宏可以用于快速创建 pthread_mutex_t 类型的互斥锁和 pthread_cond_t 类型的条件变量，常见的宏定义有以下两种：</p><ol><li>PTHREAD_MUTEX_INITIALIZER</li></ol><p>这个宏可以用来静态地初始化一个互斥锁。</p><p>示例：</p><pre><code>pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;</code></pre><ol><li>PTHREAD_COND_INITIALIZER</li></ol><p>这个宏可以用来静态地初始化一个条件变量。</p><p>示例：</p><pre><code>pthread_cond_t myCondVar = PTHREAD_COND_INITIALIZER;</code></pre><p>需要注意的是，使用这些宏定义初始化互斥锁和条件变量时，不能在初始化后使用 pthread_mutex_init() 和 pthread_cond_init() 函数对其进行初始化。</p><p>使用这些宏定义仅仅可以用于静态初始化，即这些互斥锁和条件变量的生命周期与程序的生命周期一样长。如果需要在运行时动态创建锁或条件变量，仍然需要使用相应的 pthread 函数进行初始化。</p><h3 id="条件变量总是要跟互斥锁搭配用"><a href="#条件变量总是要跟互斥锁搭配用" class="headerlink" title="条件变量总是要跟互斥锁搭配用"></a>条件变量总是要跟互斥锁搭配用</h3><p>进到wait说明拿到锁了，但是wait阻塞就说明条件没成立，所以wait会把锁给释放了，别人去抢，别人抢到干完活使得你的条件满足了，别人内部调用唤醒你，此时别人把锁释放把你唤醒，触发你等待的条件，你条件满足了，拿到锁，wait不再阻塞继续执行你的任务</p><p><strong><font color='pink'>流程如下：</font></strong></p><p>pthread 条件变量是一种同步机制，通常用于在多个线程之间进行通信和控制。条件变量通常用于通知其他线程某个特定的事件已经发生，从而触发一些操作。</p><p>pthread 条件变量的过程通常以上述步骤进行：</p><ol><li>定义条件变量和互斥锁</li></ol><p>在使用条件变量时，首先要定义一个互斥锁和一个条件变量。</p><pre><code class="c">pthread_mutex_t myMutex;pthread_cond_t myCondVar;</code></pre><ol><li>初始化条件变量和互斥锁</li></ol><p>在使用之前，需要使用 pthread_mutex_init() 函数和 pthread_cond_init() 函数对条件变量和互斥锁进行初始化。</p><pre><code class="c">pthread_mutex_init(&amp;myMutex, NULL);pthread_cond_init(&amp;myCondVar, NULL);</code></pre><ol><li>进入临界区</li></ol><p>在要等待特定事件的线程进入临界区时，需要先加锁，这样可以确保只有一个线程能够访问共享资源。</p><pre><code class="c">pthread_mutex_lock(&amp;myMutex);</code></pre><ol><li>检查条件并等待</li></ol><p>接下来，线程应该检查它等待的条件是否已经满足，如果满足，则跳过等待，离开临界区。如果不满足，线程则应该调用 pthread_cond_wait() 函数等待通知。</p><pre><code class="c">while (!condition) &#123;    pthread_cond_wait(&amp;myCondVar, &amp;myMutex);&#125;</code></pre><p>当线程调用 pthread_cond_wait() 函数时，它会释放互斥锁并等待条件变量。如果另一个线程使用 pthread_cond_signal() 函数或 pthread_cond_broadcast() 函数唤醒了等待的线程，则该线程就会重新获得互斥锁并继续执行。</p><p>需要注意，在取消等待的情况下可能会产生死锁，因此在使用 pthread_cond_wait() 函数时需要确保计算所有可能的退出情况。</p><ol><li>离开临界区</li></ol><p>当等待线程收到通知时，它应该离开等待循环并立即再次锁定互斥锁。在重新锁定互斥锁之前，条件变量的状态可以更改，因此需要重新检查条件变量并跳过等待循环，如果在等待期间已经满足条件变量，则跳过等待循环。</p><pre><code class="c">if (condition) &#123;    // 条件满足，跳过等待循环&#125; else &#123;    // 继续等待&#125;pthread_mutex_unlock(&amp;myMutex);</code></pre><ol><li>销毁条件变量和互斥锁</li></ol><p>在使用完条件变量和互斥锁之后，应该使用 pthread_cond_destroy() 函数和 pthread_mutex_destroy() 函数进行销毁。</p><pre><code class="c">pthread_cond_destroy(&amp;myCondVar);pthread_mutex_destroy(&amp;myMutex);</code></pre><p><strong>写个链表，生产者消费者demo</strong>：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;pthread.h&gt;typedef struct Node&#123;    int val;    struct Node* next;&#125;Node;/*c语言这么写出错：原因：Node* next 中的 Node 不是一个已经定义的类型，而是相对于 struct Node 的一个未知类型的指针typedef struct Node&#123;    int val;    Node* next; ***这里&#125;Node;c语言得指明struct，c++不用，C并不支持和C++一样的自动搜寻结构体定义的语法*/Node* head=NULL;//pthread_cond_t mutex = PTHREAD_COND_INITIALIZER;pthread_mutex_t mutex;  //可以直接用宏 ，主函数就不用init了，信号量也是如此pthread_cond_t hasnode;void * producer(void* arg)&#123;    Node* pre;    while(1)    &#123;        pre=(Node*)malloc(sizeof(Node));        pre-&gt;val=rand()%100;        //头插        pthread_mutex_lock(&amp;mutex);        pre-&gt;next=head;        head=pre;                pthread_mutex_unlock(&amp;mutex);        pthread_cond_signal(&amp;hasnode);        printf(&quot;produce %d\n&quot;,pre-&gt;val);        sleep(rand()%3);    &#125;&#125;void* concumer(void* arg)&#123;    Node* pre;    while(1)    &#123;        pthread_mutex_lock(&amp;mutex);        if(!head)        &#123;            pthread_cond_wait(&amp;hasnode, &amp;mutex);        &#125;        pre=head;        head=head-&gt;next;        pthread_mutex_unlock(&amp;mutex);        printf(&quot;concumer %d\n&quot;,pre-&gt;val);        free(pre);        sleep(rand()%3);    &#125;&#125;int main()&#123;    srand(time(NULL));    pthread_mutex_init(&amp;mutex, NULL);    pthread_cond_init(&amp;hasnode, NULL);    printf(&quot;start!!\n&quot;);    pthread_t pid,cid;    pthread_create(&amp;pid,NULL,producer,NULL);    pthread_create(&amp;cid,NULL,concumer,NULL);    pthread_join(pid,NULL);    pthread_join(cid,NULL);        pthread_mutex_destroy(&amp;mutex);    pthread_cond_destroy(&amp;hasnode);    printf(&quot;over!!\n&quot;);    return 0;&#125;</code></pre><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230531001916766.png" >        </sapn>      </p><p><strong>生产者消费者的demo：</strong></p><p>注意拿信号量要在拿锁之前，想想为什么？</p><p>我这篇博客有讲：<a href="https://blog.csdn.net/weixin_51609435/article/details/129400622"> 信号量解决生产者消费者&#x2F;读写者问题_右大臣的博客-CSDN博客</a></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;semaphore.h&gt;#include &lt;pthread.h&gt; // 链表的节点struct Node&#123;    int number;    struct Node* next;&#125;; // 生产者线程信号量sem_t psem;// 消费者线程信号量sem_t csem; // 互斥锁变量pthread_mutex_t mutex;// 指向头结点的指针struct Node * head = NULL; // 生产者的回调函数void* producer(void* arg)&#123;    // 一直生产    while(1)    &#123;        // 生产者拿一个信号灯        sem_wait(&amp;psem);        // 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁        pthread_mutex_lock(&amp;mutex);        // 创建一个链表的新节点        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));        // 节点初始化        pnew-&gt;number = rand() % 1000;        // 节点的连接, 添加到链表的头部, 新节点就新的头结点        pnew-&gt;next = head;        // head指针前移        head = pnew;        printf(&quot;+++producer, number = %d, tid = %ld\n&quot;, pnew-&gt;number, pthread_self());        pthread_mutex_unlock(&amp;mutex);         // 通知消费者消费        sem_post(&amp;csem);                // 生产慢一点        sleep(rand() % 3);    &#125;    return NULL;&#125; // 消费者的回调函数void* consumer(void* arg)&#123;    while(1)    &#123;        sem_wait(&amp;csem);        pthread_mutex_lock(&amp;mutex);        struct Node* pnode = head;        printf(&quot;--consumer: number: %d, tid = %ld\n&quot;, pnode-&gt;number, pthread_self());        head  = pnode-&gt;next;        // 取出链表的头结点, 将其删除        free(pnode);        pthread_mutex_unlock(&amp;mutex);        // 通知生产者生成, 给生产者加信号灯        sem_post(&amp;psem);         sleep(rand() % 3);    &#125;    return NULL;&#125; int main()&#123;    // 初始化信号量    sem_init(&amp;psem, 0, 5);  // 生成者线程一共有5个信号灯    sem_init(&amp;csem, 0, 0);  // 消费者线程一共有0个信号灯    // 初始化互斥锁    pthread_mutex_init(&amp;mutex, NULL);     // 创建5个生产者, 5个消费者    pthread_t ptid[5];    pthread_t ctid[5];    for(int i=0; i&lt;5; ++i)    &#123;        pthread_create(&amp;ptid[i], NULL, producer, NULL);    &#125;     for(int i=0; i&lt;5; ++i)    &#123;        pthread_create(&amp;ctid[i], NULL, consumer, NULL);    &#125;     // 释放资源    for(int i=0; i&lt;5; ++i)    &#123;        pthread_join(ptid[i], NULL);    &#125;     for(int i=0; i&lt;5; ++i)    &#123;        pthread_join(ctid[i], NULL);    &#125;     sem_destroy(&amp;psem);    sem_destroy(&amp;csem);    pthread_mutex_destroy(&amp;mutex);     return 0;&#125; </code></pre>]]></content>
      
      
      <categories>
          
          <category> C进阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C系统编程</title>
      <link href="/2023/05/22/C-linux/"/>
      <url>/2023/05/22/C-linux/</url>
      
        <content type="html"><![CDATA[<h1 id="练气期"><a href="#练气期" class="headerlink" title="练气期"></a>练气期</h1><p>os就是操作系统，，linux，windows</p><h3 id="文件io标准库函数和系统调用关系"><a href="#文件io标准库函数和系统调用关系" class="headerlink" title="文件io标准库函数和系统调用关系"></a>文件io标准库函数和系统调用关系</h3><p>fopen c的库函数，open系统调用，用fopen，就是fopen(3)库函数，用fopen底层会调open系统调用，调的open其实就是open(2)</p><p>man帮助的顺序</p><p>标准库函数都是在用户空间调用的</p><p>fopen调用open，open打开指定文件，返回一个文件描述符（一个int类型的编号），（分配一个FILE结构体，其中包含该文件的描述符，io缓冲区和当前读写位置等信息）返回增FILE结构体的地址</p><p>fd&#x3D;FILE*.      这个FILE * 被经常称作 句柄或者上下文。意思就是我们只需要操作句柄，但是结果表现的是我们对于内部文件做了操作</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531004721672.png" >        </sapn>      </p><hr><p>然后fgetc(fd) ，会发现这些库函数都是操作的对应的数据结构，而不是真正的文件，而真正的文件都是通过系统调用操作的</p><p>fgetc也是调read </p><p>fgets是先通过FILE*参数找到文件的描述符，io缓冲区和当前读写位置，判断能否从io缓冲区读到下一个字符，如果能读到就直接返回该字符。否则调用read，把文件描述符传进去，让内核读取改文件数据到io缓冲区，然后返回下一个字符</p><p>比如fgets要读A，，但是io缓冲区空的，所以就会调read，让内核去文件读，读到缓冲区，假如读了ABC到缓冲区，然后返回缓冲区里的A就行，读写位置移动。假如在调一个fgets，就会直接从缓冲区读了，而调不到read系统调用了。。</p><p>read只是缓冲区空了，才让内核去文件读东西到缓冲区</p><hr><p>fputc会调write给文件写</p><p>同样也是看io缓冲区是否有空间，有空间了，就写到缓冲区，，当缓冲区满了，才会调用write，让内核把缓冲区的内容写进文件</p><hr><p>fclose -&gt;close</p><p>如果调用fclose，缓冲区还有数据，那么调fclose底层会调write把缓冲区的内容写到文件，这样用户空间才是空的，然后才调用close关闭文件，释放FILE结构体和缓冲区</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531004828050.png" >        </sapn>      </p><p>缓冲区就好像菜鸟驿站一样，存到一定量了或者触发某些条件了才去发快递，在驿站收快递同理</p><p>缓冲区分为：全缓冲，行缓冲，无缓冲</p><p>全缓冲就是只有缓冲区填满了才会触发系统调用</p><p>行缓冲就是当出现换行\n或者填满 都会触发系统调用</p><p>无缓冲就是有东西就调用系统调用，像stderr输出错误的就是无缓冲，stdout输出屏幕就是行缓冲</p><p>注意linux下一切皆文件,open能打开任意的东西</p><h3 id="open"><a href="#open" class="headerlink" title="open"></a><strong>open</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531004901750.png" >        </sapn>      </p><h3 id="close"><a href="#close" class="headerlink" title="close"></a><strong>close</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531004938213.png" >        </sapn>      </p><p>比如打开三个文件abc，先打开a 打开b，然后关闭a ，再打开c ，最后关闭b，关闭c</p><p>打印他们的文件描述符fd会发现是3 4 3，，为啥？因为0 1 2是标准输入输出和错误。最新的文件描述符只能从后面开始，a是3 ，b是4。当a关闭之后，再open，此时3号描述符是空的了，且返回当前最小的fd给文件，那么c的fd就会被分配给3 </p><h3 id="read"><a href="#read" class="headerlink" title="read"></a><strong>read</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005023371.png" >        </sapn>      </p><p>read读的就是内核里面真正的文件位置，c标准库调的读返回的是那个缓冲区buff的位置,如果读到文件尾就提前返回了，即使没有读够count个字节；从终端设备读，是以行读的，遇到换行就读完退出</p><p>小问题tips:  shell是个程序，一直在监听stdin。。比如执行程序 .&#x2F;a.out ，shell就退居幕后， .&#x2F;a.out这个程序出来监听stdin，，我们输入20个字符，但是.&#x2F;a.out这个假如只读10个字节，读完之后a.out退出，，那么shell提到前面，继续监听stdin，那么他就会读到stdin输入流剩下那十个字节，把他当成命令去执行。。这样就会出问题</p><pre><code class="c">#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main(int argc,int *argv[])&#123;    if(argc&lt;2)&#123;   个人 组 其他        printf(&quot;--help&quot;);                  读写执行        return -1;                         rwx    &#125;                                      rw- r-- r--   // int fd=open(argv[1],O_WRONLY|O_CREAT,0644);    int fd=open(argv[1],O_RDONLY);    if(fd&lt;0)&#123;        perror(&quot;OPEN err&quot;);        return -1;    &#125;    else&#123;        perror(&quot;xxx&quot;);    &#125;    char buff[1024];    ssize_t n=read(fd,buff,10);        int fc=open(&quot;b.txt&quot;,O_WRONLY|O_CREAT,0644);    write(fc,buff,10);    close(fd);    close(fc);    return 0;&#125;    ./main  a.txtargv    0   1</code></pre><h3 id="非阻塞的读写"><a href="#非阻塞的读写" class="headerlink" title="非阻塞的读写"></a><strong>非阻塞的读写</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005050125.png" >        </sapn>      </p><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a><strong>fcntl</strong></h3><p>用来改变一个已打开的文件的属性，而不必重新open文件，可以设置读写，追加，非阻塞等标志,也能去给文件上锁，上了之后就是说这个文件这一段时间只能我这个进程去用。</p><p>fcntl功能很多</p><pre><code class="c">#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int main()&#123;    int flags=0;    //给标准输入设置非阻塞权限    if((flags=fcntl(STDIN_FILENO,F_GETFL))&lt;0)    &#123;        perror(&quot;get flags err\n&quot;);        exit(-1);    &#125;    flags|=O_NONBLOCK;    if((flags=fcntl(STDIN_FILENO,F_SETFL,flags))&lt;0)    &#123;        perror(&quot;set flags err\n&quot;);        exit(-1);    &#125;     &#39;&#39;&#39;读写数据    return 0;&#125;</code></pre><p>流的重定向   标准输入流&gt;      &lt;标准输出流 </p><h3 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a><strong>mmap内存映射</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005115279.png" >        </sapn>      </p><p>addr如果为空，内核会自己在进程地址空间选择合适的地址建立映射，我们可以给addr一个地址，这个地址只不过是建议的，内核会从给的这个地址开始往上找合适的位置，真正的映射的首地址可以通过mmap返回值拿到</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005143307.png" >        </sapn>      </p><p>linux 可以用 -txl -tc 文件，查看文件里面每个字符的ASCII值的16进制</p><pre><code class="c">#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/mman.h&gt;int main(int argc,int *argv[])&#123;    if(argc&lt;2)&#123;        printf(&quot;--help&quot;);                          return -1;                          &#125;                                         // int fd=open(argv[1],O_WRDONLY|O_CREAT,0644);    int fd=open(argv[1],O_RDWR);    if(fd&lt;0)&#123;        perror(&quot;OPEN err&quot;);        return -1;    &#125;    else&#123;        perror(&quot;xxx&quot;);    &#125;    char *p=mmap(NULL,10,PROT_WRITE,MAP_SHARED,fd,0);    for(int i=0;i&lt;5;++i)    &#123;        p[i]=&#39;a&#39;;    &#125;    munmap(p,10);    close(fd);    return 0;&#125;</code></pre><h3 id="ext2文件系统"><a href="#ext2文件系统" class="headerlink" title="ext2文件系统"></a><strong>ext2文件系统</strong></h3><p>树状结构</p><p>linux早期的文件系统</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005224156.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005309692.png" >        </sapn>      </p><p><strong>inode表要理解，，很重要. 一个文件除了数据之外的别的标识都在存在inode表里面。inode就是对整个文件的管理信息表</strong> ，，注意每个文件的文件名没有存在自己的inode或者数据块中，，而是存在此文件当前的上级目录中，目录中数据块会存当前目录下的文件夹，文件的名字</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005334099.png" >        </sapn>      </p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a><strong>stat</strong></h3><p>stat系统调用或者liunx封装的stat命令，可以查当前文件的状态,inode，blocks,大小，链接数，权限等</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005409584.png" >        </sapn>      </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h3><p>软链接就是真的重新创建了一个文件，类似windows的快捷方式，，硬链接只是给文件起了别名，给硬链接数+1了，</p><h3 id="遍历目录数据块的记录"><a href="#遍历目录数据块的记录" class="headerlink" title="遍历目录数据块的记录"></a><strong>遍历目录数据块的记录</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005442301.png" >        </sapn>      </p><h3 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a><strong>VFS虚拟文件系统</strong></h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005501741.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005534365.png" >        </sapn>      </p><h3 id="dup和dup2做重定向"><a href="#dup和dup2做重定向" class="headerlink" title="dup和dup2做重定向"></a><strong>dup和dup2</strong>做重定向</h3><p>oldfd去覆盖newfd，执行完该命令后，newfd如果在使用，就关闭，完了newfd就指向oldfd指向的那个文件</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005637653.png" >        </sapn>      </p><pre><code class="c">&#39;&#39;&#39;头文件&#39;&#39;&#39;int main()&#123;    int fd,save_fd;    if((fd=open(&quot;test.txt&quot;,O_RDWR))&lt;0)    &#123;        perror(&quot;open err\n&quot;);        exit(1);    &#125;        save_fd=dup(1);    dup2(fd,1);      close(fd);    char*buf=&quot;nihao&quot;;    write(1,buf,strlen(buf));    dup2(save_fd,1);    write(1,buf,strlen(buf));    close(save_fd);    return 0;&#125;</code></pre><p>上面dup和dup2做个文件重定向的逻辑解释</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005703843.png" >        </sapn>      </p><h1 id="神通期"><a href="#神通期" class="headerlink" title="神通期"></a>神通期</h1><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>复制进程，，调用失败返回-1</p><p>调用成功：父亲fork成功拿到儿子的pid，，儿子被成功复制出来之后儿子拿到的是0</p><pre><code class="c">#include&lt;unistd.h&gt;pid_t fork(void)    </code></pre><p>不同的地方：pid，内存锁没有被继承，</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005729329.png" >        </sapn>      </p><p>fork之后就会进到内核态，子进程复制出来之后，切回用户态，此时父进程和子进程两个此时都是处于就绪状态，所以不加控制的话，他们的运行顺序是由cpu去调度</p><h4 id="两句话说清孤儿和僵尸进程"><a href="#两句话说清孤儿和僵尸进程" class="headerlink" title="两句话说清孤儿和僵尸进程"></a>两句话说清孤儿和僵尸进程</h4><p>bash起来，运行a程序（这个a程序其实就是bash的儿子），此时bash就退到后台去，cpu把a程序占着，此时a程序fork出一个a1子进程，当a程序先结束，会产生一个尸体（退出码），bash睡的好好的，被尸体这个东西给惊醒了，那么bash就会起来去给a程序收尸，此时bash其实就是可以继续正常去执行新的程序了，但此时 a1这个对于bash来说的这个孙子进程还没结束，但是他的父亲a已经死了，此时就称a1这个进程是孤儿进程，，那等a1执行完了谁给他收尸呢？其实是被一个叫init进程去收尸了，所以此时a1他的父进程就成了init，其实当他的老父亲a先于他结束的那一刻，a1的父亲就成了init进程，init就是操作系统中开天辟地中的老祖宗，第一个进程。</p><pre><code class="c">set follow-fork-mode parentset follow-fork-mode child多进程去gdb，模式设置，看是去跟随哪个进程</code></pre><h4 id="exec族"><a href="#exec族" class="headerlink" title="exec族"></a>exec族</h4><p>操作系统多个程序就怎么跑的，就是通过fork+exec</p><p>exec就是用新程序去替换你刚刚新fork出来的那个子进程</p><p>如果exec调用成功，就会加载新的程序从启动代码处开始执行，就不在返回了</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005748066.png" >        </sapn>      </p><p>试试这个demo代码：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    printf(&quot;path value=[%s]\n&quot;,getenv(&quot;PATH&quot;));    setenv(&quot;PATH&quot;,&quot;hell&quot;,1);  //在当前程序里面把path环境变量改成hell了                          //相当于你子进程去改了环境变量                        //但你的终端的好比父进程，他的path其实是没有被改的，所以不用担心        完了你在终端 $PATH查看一下就知道了    extern char** environ;    for(int i=0;environ[i]!=NULL;++i)    &#123;        printf(&quot;%s\n&quot;,environ[i]); #把你操作系统的环境变量全打印出来了    &#125;    return 0;&#125;</code></pre><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005813376.png" >        </sapn>      </p><h4 id="wait，waitpid"><a href="#wait，waitpid" class="headerlink" title="wait，waitpid"></a>wait，waitpid</h4><p>一个进程终止是会关闭所有的文件描述符，释放在用户空间分配的内存，但他的pcb还保存的，内核在pcb中还保存一些信息，如果是正常终止则保存着退出状态，是异常退出则保存着导致该进程终止的信号是哪个</p><p>用wait&#x2F;waitpid可以获取这些信息，然后彻底清除这个进程</p><p>查看状态信息，Z+就代表当前进程是个僵尸进程</p><p>kill-9没法杀已经是僵尸的进程，，可以杀僵尸进程他爹，这样僵尸就会成孤儿，被init收尸</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005830775.png" >        </sapn>      </p><h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005845507.png" >        </sapn>      </p><h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>pipe，，信息一个时刻只能单向流通，父子进程用，fd[0]读端，fd[1]写端</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005901177.png" >        </sapn>      </p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main()&#123;    int fd[2];    char buf[20];    if(pipe(fd)&lt;0)    &#123;        perror(&quot;pipe&quot;);        exit(1);    &#125;    pid_t pid=fork();    if(pid&lt;0)    &#123;        perror(&quot;fork&quot;);        exit(1);    &#125;    else if(pid=0)    &#123;        close(fd[0]);        write(fd[1],&quot;hello pipe\n&quot;,11);        wait(NULL);    &#125;    else&#123;        close(fd[1]);        int n=read(fd[0],buf,20);        write(1,buf,n);//写到输出到屏幕上    &#125;    return 0;&#125;</code></pre><h4 id="管道popen和pclose，，两个集成化的函数"><a href="#管道popen和pclose，，两个集成化的函数" class="headerlink" title="管道popen和pclose，，两个集成化的函数"></a>管道popen和pclose，，两个集成化的函数</h4><p>这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭管道的不使用端，exec一个cmd命令，等待命令终止</p><pre><code class="c">FILE *popen(const char*commmand,const char*type);返回，若成功则为文件指针，若出错，则为NULLint pclose(FILE*stream) 返回command的终止状态，出错返回-1</code></pre><p>popen打开管道，fork，调用exec执行command的并且返回一个标准文件io的指针</p><p>type为r ，将文件指针连接到cmd的标准输出，，w连接到cmd的标准输入</p><pre><code class="c">&#123;    FILE*fp=popen(&quot;cat ./hexo.txt&quot;,&quot;r&quot;);  //打印到屏幕上                FILE*fp=popen(&quot;./hexo&quot;,&quot;w&quot;);  //运行hexo这个程序，往屏幕上输出    &#125;</code></pre><h4 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h4><p>不拘泥于父子进程</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531005919050.png" >        </sapn>      </p><h4 id="共享内存，最快的ipc"><a href="#共享内存，最快的ipc" class="headerlink" title="共享内存，最快的ipc"></a>共享内存，最快的ipc</h4><p>通过ftok把内核中共享内存那块结构key获取，然后用shmget把key传进去，拿到这块共享内存id，通过shmat把共享内存和用户空间进行映射，后面用户通过映射的地址进行操作</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531010004630.png" >        </sapn>      </p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>整体流程</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531010018920.png" >        </sapn>      </p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>kill -l  可以列出系统支持的信号</p><ol><li><code>ulimit -a</code> 命令用于显示当前 shell 进程的所有限制。而 <code>ulimit -c</code> 命令用于设置或显示当前 shell 进程的 core 文件大小限制。</li></ol><ul><li><p>Core 文件是在程序运行发生错误时操作系统自动生成的一种文件，并记录了程序错误发生时的内存状态、寄存器内容等信息。通过分析 Core 文件可以定位并修复程序错误。</p></li><li><p>程序段错误（Segmentation Fault）通常是指程序在访问无效的内存地址或者尝试对只读内存进行写操作时，由操作系统抛出的一种信号，导致程序异常退出或者崩溃。这通常是由于程序代码编写不当、内存泄漏等问题导致的。</p></li><li><p>Core Dump（核心转储），通常指在程序运行出现严重错误导致程序终止时，操作系统会自动保存程序在此时的内存状态和在运行过程中的其他数据到磁盘上，以 Core 文件的形式保存，以便程序员或开发人员在出现问题时进行程序调试。</p><p><strong><font color='orange'>发生core dump其实程序错误就是生成core文件了，一般core文件的大小默认的是0，0这个大小的话，系统默认是不会产生core文件的，如果想产生core文件就得修改大小，用ulimit -a，查看一下系统现在这个core的size是多少，完了用<code>ulimit -c</code>去设置一下core文件大小，这样程序错误发生core dump才能生成core 文件，我们才能根据core文件去定位错误，出现core文件了，用gdb +你出错的程序+生成的core文件 可以去调式 ，操作比如：gdb进去用bt查看调用堆栈情况</font></strong></p></li></ul><h3 id="三个函数越来越具体了"><a href="#三个函数越来越具体了" class="headerlink" title="三个函数越来越具体了"></a>三个函数越来越具体了</h3><p>abort很强，无论如何abort都会让你这个程序终止，属于异常终止，程序结束后会产生core dump</p><h3 id="有关exit"><a href="#有关exit" class="headerlink" title="有关exit"></a>有关exit</h3><p>在Linux&#x2F;Unix系统中，exit命令可以让进程（包括shell进程）退出，并返回一个退出状态码。一般情况下，该命令有以下几种情况：</p><ol><li>exit 0：表示正常退出，返回状态码为0。该状态码表示程序成功执行完成。</li><li>exit 1-255：表示异常退出，返回状态码为1到255。此时，状态码的含义由程序员自行定义，不同状态码代表不同的出错原因。</li><li>exit -n：用于在脚本中设置退出状态码。其中，-n表示状态码，表示程序在执行完当前命令后，退出并返回该状态码。</li><li>exit：表示不带参数的exit命令，这时会直接退出当前进程，但不会返回状态码，这种情况也可以被认为是正常退出，默认会返回状态码0。</li></ol><p>需要注意的是，exit命令只是让当前进程退出，并不会影响其他进程。如果想要让某个进程的子进程也一并退出，可以使用kill命令来发送SIGTERM（或其他信号）信号，以达到强制退出的目的。</p><h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>alarm函数可以设置一个闹钟，告诉内核在多少秒之后给当前进程法sigalrm信号</p><p>一般使用该函数来进行定时任务的处理。alarm只有一个定时器，比如我刚开始设置5s，然后睡眠3s，这时候还有2s才会发信号退出，此时我在设置alarm为5s，定时器就又成剩的2s变成5s，而不会2s加5s变成7s</p><h3 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h3><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531010041472.png" >        </sapn>      </p><p>如果在进程解除对某个信号的阻塞之前这种信号产生过多次，怎么处理的？</p><p>linux：是这么搞的，对于常规信号34号之前的，如果产生多次，只计算一次。比如你按了好多次ctrl+c，他操作系统都会认为是一次，等不阻塞了，ctrl+c就成功退出了。</p><p>对于实时信号34号之后的，在递达之前产生多次，会依次放在一个队列里面</p><p><strong>阻塞信号集也叫做当前进程的信号屏蔽字</strong></p><p>对于pending和block这俩信号集，0就是通过，1不通过；可以通过信号集的函数，去设置我们设置的信号集合是否阻塞的状态，如果设置了阻塞，相当于这个信号你就收不到了，对应block位置成1</p><p>示例：如上图，我们可以把（1,2,3,4）号信号，这个信号集去全都通过信号集函数去设置阻塞的状态1，把他们加到信号屏蔽字中，之后我们对于这四个信号就收不到了</p><p>不能理解我说的这句话，看看gpt理解的：</p><p>        <span class="lazyload-img-span">        <img              data-src="C:/Users/oorik/AppData/Roaming/Typora/typora-user-images/image-20230531010116008.png" >        </sapn>      </p><h4 id="相关的流程函数如下："><a href="#相关的流程函数如下：" class="headerlink" title="相关的流程函数如下："></a>相关的流程函数如下：</h4><p>信号屏蔽字是一种用于控制进程对信号的接收和处理的机制，可以通过设置信号屏蔽字来屏蔽或解除屏蔽某些信号。在Linux&#x2F;Unix系统中，可以使用sigprocmask函数和相关函数对信号屏蔽字进行操作。</p><ol><li>sigprocmask函数</li></ol><p>sigprocmask函数用于设置或获取当前进程的信号屏蔽字，其原型如下：</p><pre><code class="c">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></pre><p>其中，参数how用于指定屏蔽字需要进行的操作类型，可以选择以下值：</p><ul><li>SIG_BLOCK：加入（阻塞）信号集</li><li>SIG_UNBLOCK：移除（解除阻塞）信号集</li><li>SIG_SETMASK：设置（替换）信号集</li></ul><p>参数set用于指定需要设置的信号集，参数oldset用于记录原先设置的信号集。</p><p><strong>sigprocmask</strong>函数的使用方法如下：</p><p>（1）创建一个信号集</p><p>使用sigemptyset函数清空一个信号集，并使用sigaddset函数向其中加入需要设置的信号。</p><p>（2）设置信号屏蔽字</p><p>使用sigprocmask函数设置进程的信号屏蔽字，将信号集中的相应信号加入或移除出屏蔽字。</p><ol><li>sigaddset和sigemptyset函数</li></ol><p>sigaddset函数用于向信号集中添加一个信号，其原型如下：</p><pre><code class="c">int sigaddset(sigset_t *set, int signum);</code></pre><p>其中，参数set为要操作的信号集，参数signum为需要添加的信号编号。</p><p>sigemptyset函数用于清空一个信号集，其原型如下：</p><pre><code class="c">int sigemptyset(sigset_t *set);</code></pre><p>其中，参数set为要操作的信号集。</p><p>使用这两个函数的步骤如下：</p><p>（1）定义一个空信号集：</p><pre><code class="c">sigset_t myset;sigemptyset(&amp;myset);</code></pre><p>（2）向信号集中加入要操作的信号：</p><pre><code class="c">sigaddset(&amp;myset, SIGUSR1);</code></pre><ol><li>sigismember函数</li></ol><p>sigismember函数用于查询一个信号是否在信号集中，其原型如下：</p><pre><code class="c">int sigismember(const sigset_t *set, int signum);</code></pre><p>其中，参数set为要操作的信号集，参数signum为需要查询的信号编号。如果查询到信号在信号集中，则返回1；否则返回0。</p><p>2.sigpending用来检查操作未决信号集</p><pre><code class="c">int sigpending(sigset_t *set);</code></pre><p>做一个简单示例，加入阻塞信号集，判定在不在未决信号集里面</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;void handler(int sig)&#123;    printf(&quot;Signal %d received.\n&quot;, sig);&#125;int main()&#123;    // 设置信号处理程序    signal(SIGINT, handler);    // 创建一个信号集    sigset_t set;    // 初始化信号集，将所有信号都清除    sigemptyset(&amp;set);    // 将SIGINT信号添加到信号集中    sigaddset(&amp;set, SIGINT);    // 阻塞SIGINT信号    sigprocmask(SIG_BLOCK, &amp;set, NULL);    // 检查是否有未决的信号    if (sigpending(&amp;set) == 0)    &#123;        if (sigismember(&amp;set, SIGINT))        &#123;            printf(&quot;There is a pending SIGINT signal.\n&quot;);        &#125;    &#125;    // 解除阻塞    sigprocmask(SIG_UNBLOCK, &amp;set, NULL);    return 0;&#125;</code></pre><p>这些函数能够允许我们对信号屏蔽字进行正确有效的操作，有助于我们控制程序对信号的处理。</p><h3 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h3><p>我们自己自定义相应的信号处理函数</p><p>对于我们自定义的信号处理，操作系统总是在内核回退到用户空间之前这个时刻去处理，这样的效率会高，如果每次遇到信号我都要从用户空间跑到内核去处理，再回退，这样效率很低。流程如下图：</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C-linux/image-20230531010136501.png" >        </sapn>      </p><h4 id="pause函数可以使调用进程挂起，直到信号到达"><a href="#pause函数可以使调用进程挂起，直到信号到达" class="headerlink" title="pause函数可以使调用进程挂起，直到信号到达"></a>pause函数可以使调用进程挂起，直到信号到达</h4><p>sigsuspend函数包含了pause的挂起等待功能，同时解决了时序竞争的问题，在对时序有严格要求的场合要用sigsupend</p>]]></content>
      
      
      <categories>
          
          <category> C进阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>auto关键字进阶</title>
      <link href="/2023/05/22/auto1/"/>
      <url>/2023/05/22/auto1/</url>
      
        <content type="html"><![CDATA[<h1 id="auto💓"><a href="#auto💓" class="headerlink" title="auto💓"></a>auto💓</h1><h3 id="本篇开启Cpp进阶系列"><a href="#本篇开启Cpp进阶系列" class="headerlink" title="本篇开启Cpp进阶系列"></a>本篇开启Cpp进阶系列</h3><p>&#x3D;&#x3D;auto在编译期间自动推导出变量的类型。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。&#x3D;&#x3D;</p><p>auto在版本迭代中技巧太多，下面简单总结。注意auto是不能用在定义数组的，下面我说的都是版本证实的</p><p>在C++11中，<code>auto</code>关键字不能用于定义数组。例如：</p><pre><code class="c++">c++复制代码auto arr[] = &#123;1, 2, 3&#125;; // 编译错误</code></pre><p>上面的示例中，<code>auto</code>关键字用于定义数组，但是编译会失败，因为编译器无法推断出数组的类型。</p><p>如果要使用<code>auto</code>关键字定义类型，则需要将其用于定义数组的元素，并使用大括号括起来初始化数组。例如：</p><pre><code class="c++">c++复制代码auto x = 1; // 推导为int类型auto arr = &#123;1, 2, 3&#125;; // 推导为std::initializer_list&lt;int&gt;eg:int main() &#123;    auto arr = &#123;1, 2, 3&#125;;    for(auto x:arr)    &#123;        cout&lt;&lt;x&lt;&lt;endl;    &#125;    getchar();    return 0;&#125;</code></pre><p>在上面的示例中，<code>auto</code>关键字用于定义变量<code>x</code>和数组<code>arr</code>的元素类型，并且使用大括号初始化<code>arr</code>数组，此时编译器可以自动推导出<code>arr</code>数组的类型为<code>std::initializer_list&lt;int&gt;</code>。</p><p>如果需要使用<code>auto</code>关键字定义数组，可以使用C++17中新增的<code>auto</code>作为数组的元素类型来实现。例如：</p><pre><code class="c++">c++复制代码auto arr = std::array&#123;1, 2, 3&#125;; // 推导为std::array&lt;int, 3&gt;</code></pre><p>在上面的示例中，使用<code>std::array</code>和<code>auto</code>关键字定义了一个数组<code>arr</code>，此时编译器可以自动推导出<code>arr</code>数组的类型为<code>std::array&lt;int, 3&gt;</code>。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11 中引入了一个新的关键字 <code>auto</code> , 用于自动型别推导. 同时引入了一个新的写法.</p><pre><code class="cpp">auto func(T parameters) -&gt; type;</code></pre><p>把函数返回类型写在后面, 这叫做 trailing return type. 这个写法等价于把 type 放在前面的通常函数, 比如</p><pre><code class="cpp">type func(T parameters);</code></pre><p><strong>所以说 <code>auto</code> 关键字只是一个占位符</strong>, 不过配合上同为 C++11 引入的 <code>decltype</code> 关键字, 就可以进行类型推导. 比如下面这个模板函数</p><pre><code class="cpp">template &lt;typename U, typename V&gt;auto add(U a, V b) -&gt; decltype(a + b);// add(float, double) 返回 double// add(float, int) 返回 float// 诸如此类</code></pre><p>这样可以通过 <code>a + b</code> 的型别推断出 <code>add</code> 函数的返回类型. 这样的话, 返回的型别就可以利用函数参数的型别所决定了.</p><h2 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h2><h3 id="新的占位符-auto"><a href="#新的占位符-auto" class="headerlink" title="新的占位符 auto"></a>新的占位符 auto</h3><p>C++14 允许你在函数定义的时候, 使用真正的 <code>auto</code> , 如果在一个函数定义的时候用上 <code>auto</code> , 那他就会按照下面这个方式推断.</p><pre><code class="cpp">auto func(T parameters)&#123;    return something;&#125;</code></pre><p>这个 auto 推导的结果就相当于</p><pre><code class="cpp">auto value = something;</code></pre><p>之中的 auto 所推导的结果. 类似地, <code>auto &amp;</code> , <code>auto &amp;&amp;</code> , <code>const auto</code> , <code>const auto &amp;</code> 等关键字也都是这个原理.</p><p>这些关键字使用上是有区别的, 比如 <code>auto &amp;</code> 只能返回左值引用, 而 <code>auto &amp;&amp;</code> 既能返回左值引用, 又能返回右值引用. <code>auto</code> 只能返回一个型别. 等等.</p><p>这样子的写法只能在函数定义中使用, 因为必须同时提供返回值才能完成推导.</p><h3 id="老的占位符-auto"><a href="#老的占位符-auto" class="headerlink" title="老的占位符 auto"></a>老的占位符 auto</h3><p>C++14 为 C++11 中这种写法</p><pre><code class="cpp">auto func(T parameter) -&gt; decltype(something) // decltype() 中就是返回值&#123;    return something;&#125;</code></pre><p>留了个简化的写法:</p><pre><code class="cpp">decltype(auto) func(T parameter)&#123;    return something;&#125;</code></pre><p>同样我们需要给出函数的 definition, 而不只是 declaration.</p><p>这就是常用的 <code>decltype(auto)</code> 的含义了.</p><p><code>decltype</code> 的推导规则和 <code>auto</code> , <code>auto &amp;</code> , <code>auto &amp;&amp;</code> , <code>const auto</code> , <code>const auto &amp;</code> 等<strong>都不一样</strong>. 它既可以返回类型, 又可以返回左右值引用, 还会保留 <code>const</code> 语义, 挺不一样的.</p><h2 id="用在-lambda-中"><a href="#用在-lambda-中" class="headerlink" title="用在 lambda 中"></a>用在 lambda 中</h2><p>定义一个典型的 lambda 实际上需要</p><ol><li>捕获 [],</li><li>函数参数 (),</li><li>返回类型 <code>type</code>,</li><li>函数定义 {}.</li></ol><pre><code class="cpp">auto f = []() -&gt; type &#123;&#125;;</code></pre><p>这里我们省略了一些关键字, 比如 <code>mutable</code> , <code>noexcept</code> 等. C++17 中还可以用 <code>constexpr</code> 等关键字.</p><p>当然这个 <code>-&gt; type</code> 也可以不写. 不写就意味着被 C++14 中的 <code>-&gt; auto</code> 占位了. 包括 C++11 也是这样的, 尽管 C++11 中还没有 <code>auto</code> 的这个用法.</p><h2 id="函数参数的-auto"><a href="#函数参数的-auto" class="headerlink" title="函数参数的 auto"></a>函数参数的 auto</h2><p>我们刚刚说的都是返回类型的地方放一个 <code>auto</code> . 我们下面来聊聊函数参数中的 <code>auto</code> .</p><h2 id="lambda-参数中的-auto"><a href="#lambda-参数中的-auto" class="headerlink" title="lambda 参数中的 auto"></a>lambda 参数中的 auto</h2><p>C++ 14 中允许了 lambda 参数使用 <code>auto</code> , <code>auto &amp;&amp;</code> 等等 C++14 的类型占位符. 你可以写出这样的代码:</p><pre><code class="cpp">auto sum = [](auto x, auto y) &#123; return x + y; &#125;;</code></pre><p><code>sum</code> 就有点像模板了, 遇到的时候会自行推断 <code>x + y</code> 的型别. 尽管如此, 你仍然不能写一个具有函数模板形式的 lambda.</p><h2 id="普通函数中的-auto"><a href="#普通函数中的-auto" class="headerlink" title="普通函数中的 auto"></a>普通函数中的 auto</h2><p>我们知道长期以来, C++ 有函数模板, 而 lambda 的参数可以用 auto 变得像函数模板一样. 这两个东西这么像, 终于在 C++20 中得到了统一.</p><p>在 C++20 中, 我们在函数参数中也可以用 <code>auto</code> , <code>auto &amp;</code> , <code>auto &amp;&amp;</code> 等等之一了. 而在 lambda 中, 我们也可以使用显式的模板参数列表了. 你可以写出:</p><pre><code class="cpp">auto add(auto x, auto y)&#123;    return x + y;&#125;</code></pre><p>这种很奇怪的代码了.</p><p>也可以写出</p><pre><code class="cpp">auto add = []&lt;typename T, typename S&gt;(T x, S y) &#123; return x + y; &#125;;</code></pre><p><strong>参考：</strong></p><p><a href="https://www.zhihu.com/column/c_1267952684679827456">C++干货系列 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/column/c_1330233721316470784">C&#x2F;C++技术 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp进阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cplusplus部分总结</title>
      <link href="/2023/05/22/cplus/"/>
      <url>/2023/05/22/cplus/</url>
      
        <content type="html"><![CDATA[<h3 id="记录我下班重温cpp的一些笔记。"><a href="#记录我下班重温cpp的一些笔记。" class="headerlink" title="记录我下班重温cpp的一些笔记。"></a>记录我下班重温cpp的一些笔记。</h3><p>[TOC]</p><pre><code class="c">new 重载 运算符 返回具体类型 抛异常 不用指定内存大小 多构造对象的过程malloc 指定内存大小 void* 返回null 二维数组分配内存int(*arr)[5]=new int[4][5];//直接全分配好int **brr=new int*[4];//同下面malloc一个意思brr[i]=new int[3];int **crr=(int**)malloc(sizeof(int*)*2);//2行的指针数组crr[i]=(int*)malloc(sizeof(int)*3);//具体每行的3个元素</code></pre><hr><p>this-&gt;  classname *const this</p><p>const成员函数中  const classname *const this ，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</p><p>this是右值，所以不能取this的地址</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230513202648323.png" >        </sapn>      </p><p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</p><hr><p>虚函数可以是内联函数吗？</p><p>可以，但是当虚函数表现出多态性就不能内联</p><p>多态-》运行期，，内联-》编译期。编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p><p><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而<strong>不是对象的指针或引用时才会发生。</strong></p><hr><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p><p>所以volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p><ul><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li><li>volatile多用在多线程</li></ul><hr><p>union任意时刻只有一个数据成员可以持有值</p><ol><li><strong>默认访问控制符为 public</strong></li><li><strong>可以含有构造函数、析构函数</strong></li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li><strong>全局匿名联合必须是静态（static）的</strong></li></ol><pre><code class="c">union unionTest&#123;   unionTest():i(10)&#123;      cout&lt;&lt;&quot;unionTest i&quot;&lt;&lt;endl;   &#125;   int i;   double d;&#125;;//全局匿名的static union&#123;   int i;   double d;&#125;;int main()&#123;   unionTest myunion;      //局部匿名union   union&#123;      int i;      double d;   &#125;;   cout&lt;&lt;myunion.i&lt;&lt;endl;   ::i=20;   cout&lt;&lt;::i&lt;&lt;endl;// 输出全局静态匿名联合的 20   i=30;   cout&lt;&lt;i&lt;&lt;endl;// 输出局部匿名联合的 30&#125;</code></pre><hr><p>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</p><p>explicit 修饰转换函数时，可以防止隐式转换</p><pre><code class="c">struct A&#123;    A(int) &#123;&#125;    operator bool() const &#123; return true; &#125;&#125;;struct B&#123;    explicit B(int) &#123;&#125;    explicit operator bool() const &#123; return true; &#125;&#125;;void doA(A a) &#123;&#125;void doB(B b) &#123;&#125;int main()&#123;    A a1(1);     // OK：直接初始化    A a2 = 1;    // OK：复制初始化    A a3&#123;1&#125;;     // OK：直接列表初始化    A a4 = &#123;1&#125;;  // OK：复制列表初始化    A a5 = (A)1; // OK：允许 static_cast 的显式转换    doA(1);      // OK：允许从 int 到 A 的隐式转换    if (a1);                            // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a6(a1);                   // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a7 = a1;                    // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a8 = static_cast&lt;bool&gt;(a1); // OK ：static_cast 进行直接初始化    B b1(1);     // OK：直接初始化    B b2 = 1;    // 错误：被 explicit 修饰构造函数的对象不可以复制初始化    B b3&#123;1&#125;;     // OK：直接列表初始化    B b4 = &#123;1&#125;;  // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化    B b5 = (B)1; // OK：允许 static_cast 的显式转换    doB(1);      // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换    if (b1);                            // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b6(b1);                     // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b7 = b1;                    // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换    bool b8 = static_cast&lt;bool&gt;(b1); // OK：static_cast 进行直接初始化    return 0;&#125;</code></pre><hr><p>c++11之后使用using可以用来声明继承构造函数</p><pre><code class="c">class Base&#123;public:    Base(int va) :m_value(va), m_c(&#39;0&#39;) &#123;&#125;    Base(char c) :m_c(c), m_value(0) &#123;&#125;private:    int m_value;    char m_c;&#125;; class Derived :public Base&#123;public:    //使用继承构造函数    using Base::Base;     //假设派生类只是添加了一个普通的函数    void display()    &#123;//dosomething    &#125;&#125;;</code></pre><p> <a href="https://blog.csdn.net/SwordArcher/article/details/88717442">https://blog.csdn.net/SwordArcher/article/details/88717442</a> using在继承构造函数中的用法(c++11)</p><hr><p>c++的多态</p><ul><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期&#x2F;运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><p>静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期，即函数地址是早绑定还是晚绑定的。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早绑定。静态多态往往也被叫做静态联编。 动态多态则是指函数调用的地址不能在编译器期间确定，需要在运行时确定，属于晚绑定，动态多态往往也被叫做动太联编</p><p><strong>编译期是指把你的源程序交给编译器编译的过程，最终目的是得到obj文件，链接后生成可执行文件（预处理、编译、汇编和链接）。 运行期指的是你将可执行文件交给操作系统（输入文件名，回车）执行、直到程序执行结束</strong>。</p><hr><h4 id="模板编译与链接"><a href="#模板编译与链接" class="headerlink" title="模板编译与链接"></a>模板编译与链接</h4><p>现在就来看看，编译器对模板是如何编译和链接吧(<a href="https://www.cnblogs.com/jinxiang1224/p/8468272.html">https://www.cnblogs.com/jinxiang1224/p/8468272.html</a>)</p><p>当编译器遇到一个template时，不能够立马为他产生机器代码，它必须等到template被指定某种类型。也就是说，函数模板和类模板的完整定义将出现在template被使用的每一个角落，比如遇到上述中的4个语句时，才能确定编译内容，否则编译器没有足够的信息产生机器代码。</p><p>对于不同的编译器，其对模板的编译和链接技术也会有所不同，其中一个常用的技术称之为Smart，其基本原理如下：</p><ol><li><p>模板编译时，以每个cpp文件为编译单位，实例化该文件中的函数模板和类模板</p></li><li><p>链接器在链接每个目标文件时，会检测是否存在相同的实例；有存在相同的实例版本，则删除一个重复的实例，保证模板实例化没有重复存在。</p></li></ol><p>比如我们有一个程序，包含A.cpp和B.cpp，它们都调用了CThree模板类，在A文件中定义了int和double型的模板类，在B文件中定义了int和float型的模板类；在编译器编译时.cpp文件为编译基础，生成A.obj和B.obj目标文件，即使A.obj和B.obj存在重复的实例版本，但是在链接时，链接器会把所有冗余的模板实例代码删除，保证exe中的实例都是唯一的。编译原理和链接原理，如下所示：</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230531002904717.png" >        </sapn>      </p><hr><p><strong>问为什么虚继承能解决菱形继承的问题？？？</strong></p><p>虚继承底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><p>虚继承用的指针是vbptr，，虚函数的是vfptr</p><p>​所谓虚函数表，是编译器自动为一个带有虚函数的类生成的一块内存空间，其中存储着每一个虚函数的入口地址。由于函数的入口地址可以看成一个指针类型，因此这些虚函数的地址间隔为四个字节。而每一个带有虚函数类的实例，都拥有一个虚函数指针——vptr，在类的对象初始化完毕后，它将指向虚函数表。</p><p>虚函数表、虚函数指针是编译期确定的，但是虚函数表里面的虚函数具体的实现方式是运行期确定的。</p><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移量，通过偏移量的指向去解决菱形继承的问题</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><hr><p>常用的一些宏，日志，调试经常用</p><p>编译器内置宏：</p><p>ANSI C标准中有几个标准预定义宏（也是常用的）：</p><ul><li><strong>LINE</strong>：在源代码中插入当前源代码行号；</li><li><strong>FILE</strong>：在源文件中插入当前源文件名；</li><li><strong>DATE</strong>：在源文件中插入当前的编译日期</li><li><strong>TIME</strong>：在源文件中插入当前编译时间；</li><li><strong>STDC</strong>：当要求程序严格遵循ANSI C标准时该标识被赋值为1；</li><li>__cplusplus：当编写C++程序时该标识符被定义，例如__cplusplus199711，__cplusplus201103。</li><li><strong>FUNCTION</strong>：调用函数的名称</li></ul><p>编译器在进行源码编译的时候，会自动将这些宏替换为相应内容。</p><p>标识符__LINE__和__FILE__通常用来调试程序；</p><p>标识符__DATE__和__TIME__通常用来在编译后的程序中加入一个时间标志，以区分程序的不同版本；</p><p>这四个都是预编译宏，不是包含在头文件中的：</p><ul><li>__FILE__是当前编译的文件的文件名 是一个字符串</li><li>__TIME__是当前编译的文件的编译时间 格式是hh:mm:ss 是字符串</li><li>__DATE__是当前编译的文件的编译日期 格式是Mmm:dd:yyyy 是字符串</li><li>__LINE__是调用该宏语句所在的行数，是个十进制数</li></ul><pre><code class="c">#include&lt;iostream&gt;using namespace std;int main()&#123;   cout&lt;&lt;&quot;line:&quot;&lt;&lt;__LINE__&lt;&lt;endl;   cout&lt;&lt;&quot;file:&quot;&lt;&lt;__FILE__&lt;&lt;endl;   cout&lt;&lt;&quot;date:&quot;&lt;&lt;__DATE__&lt;&lt;endl;   cout&lt;&lt;&quot;time:&quot;&lt;&lt;__TIME__&lt;&lt;endl;   cout&lt;&lt;&quot;version:&quot;&lt;&lt;__cplusplus&lt;&lt;endl;   cout&lt;&lt;&quot;function:&quot;&lt;&lt;__FUNCTION__&lt;&lt;endl;&#125;</code></pre><h3 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h3><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h3 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h3><ul><li>私有：线程栈，寄存器，程序计数器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h3 id="有关继承，你要知道"><a href="#有关继承，你要知道" class="headerlink" title="有关继承，你要知道"></a>有关继承，你要知道</h3><ul><li>派生类从继承可以继承来所有的成员（变量和方法），析构，友元类，函数不会继承，，同名的函数和变量不会继承，相当于隐藏了，需要自己手动调用</li></ul><p><del><strong>有的说没有继承来父类的构造和析构，，怎么说呢，个人认为其实是继承下来了，如果没有继承下来，在派生类里面怎么调用父类的构造去初始化继承来的父类的成员呢？</strong></del></p><p>复盘，构造不能被继承，初始化列表那种写法是显示调用父类构造</p><p>查询C++primer 15.7.4得到：类不会继承默认、拷贝、移动构造函数，如果派生类没有直接定义这些构造函数，编译器会自动为派生类合成这些构造</p><p>下面是gpt4的回答：</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230524002837996.png" >        </sapn>      </p><p>在C++中，派生类不能继承基类的构造函数和析构函数。这是因为构造函数和析构函数是特殊的成员函数，它们在对象的创建和销毁时自动调用，而不是由派生类继承。特殊的那些函数都不能继承</p><p>C++ Primer第五版中第15章第2节中有明确的说明：</p><blockquote><p>派生类不继承基类的构造函数或析构函数。一个派生类可以调用基类的构造函数，但是不能继承它。同样，一个派生类可以调用基类的析构函数，但是不能继承它。</p></blockquote><p>引入-》C++11中使用using继承父类构造函数的独特用法</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230531002958912.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230531003021722.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230531003051824.png" >        </sapn>      </p><pre><code class="c++">class A&#123;private:    int data;protected:    A(int a):data(a)&#123;        cout&lt;&lt;&quot;A()&quot;&lt;&lt;endl;    &#125;    ~A()&#123;cout&lt;&lt;&quot;~A()&quot;&lt;&lt;endl;&#125;&#125;;class B:public A&#123;private:    int data1;public:    B(int a):A(a),data1(a)  //是 显示调用父类构造    &#123;        cout&lt;&lt;&quot;B()&quot;&lt;&lt;endl;    &#125;    ~B()&#123;cout&lt;&lt;&quot;~B()&quot;&lt;&lt;endl;&#125;&#125;;int main(void)&#123;    B b(20);    system(&quot;pause&quot;);    return 0;&#125;</code></pre><ul><li>派生类要想初始化继承来的父类的成员，需要调用基类相应的构造函数来初始化</li><li>派生类的构造函数和析构，负责初始化和清理派生类的成员</li><li>基类的构造和析构，去负责派生类继承来的部分</li></ul><p>如果B私有继承了A，那么A里面的public和proected相对于B都成了private，B只能在他内部去访问继承下来的这些相对于他成了private的成员，</p><p>如果A里面有私有成员，在私有继承的情况下（无论什么继承情况下），父类的私有成员只能被父类本身访问和使用，而不能被派生类或其他外部类访问和使用。因此B去继承A，A的私有东西B根本无法访问的</p><p>存疑，无法访问是ok的，但是A的私有属性是否会被继承下来？ 个人认为会被继承，但是无法访问</p><p>查询gpt结论是私有成员会被继承，我写了测试demo看内存地址也是存在的</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>对于派生类和基类同名函数，参数也相同，，这种是可以的，毕竟作用域不相同。这种就叫隐藏，派生类对象想要去调和他同名的父类方法，就需要显示去调用了</p><h3 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h3><p>当基类指针或引用指向从堆上构建的派生类对象时，基类析构必须要写成虚的</p><pre><code class="c++">&#123;    Base *de=new Devire();    delete de;    de=nullptr;    return 0;&#125;</code></pre><p>虚函数一定是动态绑定吗？</p><p>不是的，只要是对象本身去调用，即使函数写的虚函数，但还是静态绑定。动态绑定也没必要，你动态绑定最后访问的不还是自己的对应的虚函数嘛</p><p>其次你在构造函数里面去调用虚函数，发生的也是静态绑定，不会发生动态绑定</p><h3 id="一道笔试题：为什么结果是Devire：10-，动态绑定调用到Devire没问题，可是i-为什么是10呢？"><a href="#一道笔试题：为什么结果是Devire：10-，动态绑定调用到Devire没问题，可是i-为什么是10呢？" class="headerlink" title="一道笔试题：为什么结果是Devire：10  ，动态绑定调用到Devire没问题，可是i 为什么是10呢？"></a>一道笔试题：为什么结果是Devire：10  ，动态绑定调用到Devire没问题，可是i 为什么是10呢？</h3><p>因为函数参数压栈这些都是在程序编译阶段，编译阶段编译器只能看到是Base指针调用show，因此i压栈为10，而动态绑定在运行阶段，运行期间发现show是虚函数，且Base指针指向的是Devire对象，所以才会去Devire里调show，因此打印的是Devire，但是i在编译时已经压栈是10了，那么打印出来的i就是10，并不是i&#x3D;20这个默认值，他毕竟没有被压到栈里</p><pre><code class="c++">class Base&#123;public:    Base()&#123;        cout&lt;&lt;&quot;BASe&quot;&lt;&lt;endl;    &#125;    virtual ~Base()&#123;        cout&lt;&lt;&quot;---BASe&quot;&lt;&lt;endl;    &#125;    virtual void show(int i=10)    &#123;        cout&lt;&lt;&quot;BAse:&quot;&lt;&lt;i&lt;&lt;endl;    &#125; &#125;;class Devire:public Base&#123;public:    Devire()&#123;        cout&lt;&lt;&quot;Devire&quot;&lt;&lt;endl;    &#125;     ~Devire()&#123;        cout&lt;&lt;&quot;---Devire&quot;&lt;&lt;endl;    &#125;    virtual void show(int i=20)    &#123;        cout&lt;&lt;&quot;Devire:&quot;&lt;&lt;i&lt;&lt;endl;    &#125;&#125;;int main()&#123;    Base *de=new Devire();    de-&gt;show();    delete de;    de=nullptr;    return 0;&#125;</code></pre><p>上面代码稍微修改一下，把派生类的show方法改为私有，结果还是跟上的一样，思考为什么？</p><pre><code class="c">class Devire:public Base&#123;public:    Devire()&#123;        cout&lt;&lt;&quot;Devire&quot;&lt;&lt;endl;    &#125;     ~Devire()&#123;        cout&lt;&lt;&quot;---Devire&quot;&lt;&lt;endl;    &#125;private:    //改为私有的了    void show(int i=20)    &#123;        cout&lt;&lt;&quot;Devire:&quot;&lt;&lt;i&lt;&lt;endl;    &#125;&#125;;</code></pre><p>要分清什么事情在编译阶段做的，什么事情在运行阶段做的，，</p><p>访问权限是在编译阶段确定的，，只有编译链接完成了才能去运行。在编译阶段编译器看到的还是Base对象去调用show方法，且i&#x3D;10压栈，他的show是公有的，此时代码的访问权限已经被确定了，因此编译是没问题的。。但是到了运行期间，编译器看到指针指的是派生类，就会通过虚表指针找到对应的虚函数去调用，他才不管你什么访问权限呢，因为你编译都通过了说明访问权限啥的代码检查是没问题的</p><h3 id="虚继承的问题"><a href="#虚继承的问题" class="headerlink" title="虚继承的问题"></a>虚继承的问题</h3><p>当b虚继承a之后，b类型就会多一个vbptr的指针。当虚继承之后，虚基类的数据就会放在派生类的最下面（原本正常继承来说，继承的东西在上面），然后派生类最上面加一个vbptr。</p><p>当虚继承+虚函数是ok的，可以正常实现多态，但是当遇到虚基类指针&#x2F;引用指向派生类对象（堆上new的）的时候，用完需要再去delete虚基类指针，内存回收就会出问题。。把上面的例子改成虚继承，可以试试</p><p>知道答案之前，先要记住：<strong>基类指针指向派生类对象，永远指向的是派生类基类部分的起始地址</strong></p><p>明白这句话之后问题的答案就显而易见了，原本正常继承的delete没有问题，因为基类部分就是在内存上面，析构从上往下没问题，，但是虚继承了之后，虚基类的内容就会跑到下面部分，指针指向下面部分去析构，但是上面却没有析构，这样就会有内存泄漏问题</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230531003112537.png" >        </sapn>      </p><p>不过我说的这个问题是在windows下vs会这样，，但是linux下g++这种情况，他会自动的给你偏移到起始位置去free的，所以linux下g++这样没问题</p><p>tips：上面普通继承里，vfptr为什么画到Base基类部分呢，因为我写的代码派生类的虚函数是从Base继承来的，如果说Base没有虚函数，派生类有虚函数，那么继承图的vfptr就应该画在Devire部分</p><h2 id="系统调用hook"><a href="#系统调用hook" class="headerlink" title="系统调用hook"></a>系统调用hook</h2><p>hook是一种技术用来截获和修改应用程序或操作系统发出的系统调用请求。其本质就是<strong>劫持函数调用</strong>。</p><h2 id="操作系统的RING0-RING3分层结构"><a href="#操作系统的RING0-RING3分层结构" class="headerlink" title="操作系统的RING0-RING3分层结构"></a>操作系统的RING0-RING3分层结构</h2><p>简单说：RING3是用户空间，RING0是内核空间</p><p>Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。</p><p>Windows只使用RING0和RING3，RING0只给操作系统用，RING3谁都能用。</p><p>如果普通应用程序企图执行RING0指令，则Windows会显示“非法指令”错误信息。因为有CPU的特权级别作保护。</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/cplus/image-20230531003151992.png" >        </sapn>      </p><p><strong>以Linux+x86为例</strong> 操作系统（内核）的代码运行在最高运行级别RING0上，可以使用特权指令，控制中断、修改页表、访问设备等。 应用程序的代码运行在最低运行级别上RING3上，不能做受控操作。如果要做，例如访问磁盘，写文件的操作，则必须通过<strong>系统调用</strong>（函数），执行系统调用的时候，CPU的运行级别会从RING3切换到RING0，并跳转到系统调用对应的内核代码位置执行，这样内核就替我们完成了设备访问的操作，完成之后再从RING0返回RING3。整个过程也称<strong>作用户态和内核态的切换</strong></p><p>如果要想做一个劫持函数：三种实现方法：</p><ol><li>在RING3这种用户空间，我们可以编写自己的动态库，利用LD_PRELOAD优先加载同名的自定义函数  （比如 自定义strcmp来覆盖C标准库的strcmp）</li><li>对于RING0内核空间，找到程序调用对应的汇编命令，修改对应的offset地址  （call  0xc106d75c <vfs_read>）让他跳到新的内核函数</li><li>利用利用0x80中断劫持system_call，获取sys_call_table的基地址，修改指定函数offset对应的系统调用了</li></ol><p><strong>这块具体代码还不是很懂，涉及汇编和底层。。留坑等以后牛逼了，学习一下–</strong></p><p><strong>出处：<a href="https://stibel.icu/md/c++/function/c++-function-Linux_Hook.html">C++函数 - Linux系统调用Hook )</a></strong></p><h2 id="C-函数-getopt函数"><a href="#C-函数-getopt函数" class="headerlink" title="C++函数 - getopt函数"></a>C++函数 - getopt函数</h2><p>linux下解析传入命令的，实现命令行参数的解析和处理。</p><pre><code class="c++">int getopt(int argc,char * const argv[ ],const char * optstring);</code></pre><p>参数argc和argv分别代表参数个数和内容，参数 optstring为选项字符串</p><p>定义一个optstring字符串，用于指定支持的命令行选项，程序用while调getopt解析输入的命令行，解析到相应的字符，在optstring有支持的，去做对应的处理就行</p><p>省略…补坑，暂时没用过</p>]]></content>
      
      
      <categories>
          
          <category> Cpp进阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cpp模板细讲</title>
      <link href="/2023/05/22/cpp%E6%A8%A1%E6%9D%BF1/"/>
      <url>/2023/05/22/cpp%E6%A8%A1%E6%9D%BF1/</url>
      
        <content type="html"><![CDATA[<h1 id="【C-】模板声明与定义不分离"><a href="#【C-】模板声明与定义不分离" class="headerlink" title="【C++】模板声明与定义不分离"></a>【C++】模板声明与定义不分离</h1><p>以下两个问题由chatgpt回答</p><h3 id="x3D-x3D-从编译阶段和运行阶段说说C-中-模板代码-是怎么变化的-x3D-x3D"><a href="#x3D-x3D-从编译阶段和运行阶段说说C-中-模板代码-是怎么变化的-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;从编译阶段和运行阶段说说C++中 模板代码 是怎么变化的?&#x3D;&#x3D;"></a>&#x3D;&#x3D;从编译阶段和运行阶段说说C++中 模板代码 是怎么变化的?&#x3D;&#x3D;</h3><blockquote><p><strong>在 C++ 中，模板代码是在编译阶段进行处理的。编译器会根据代码模板生成多个不同的实例，这些实例化的模板代码将会在运行阶段被调用。</strong></p><p><strong>在编译阶段，模板代码的定义会被解析和检查错误。编译器会根据模板参数的类型和实例化时传入的参数类型，生成符合类型要求的实际函数或类定义，并在该源代码文件或库中保存它们。</strong></p><p><strong>当程序在运行阶段调用模板实例时，相应的实例化模板代码将会被加载到内存中，根据运行时传入的实参进行处理。</strong></p><p><strong>因此，在 C++ 中，模板代码在编译时被解析，实例化，并生成可执行的代码。这使得模板函数和类成为了强大且灵活的工具，可以轻松地处理各种数据类型和算法。</strong></p></blockquote><h3 id="x3D-x3D-为什么模板的定义和声明要放在一个文件中-x3D-x3D"><a href="#x3D-x3D-为什么模板的定义和声明要放在一个文件中-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;为什么模板的定义和声明要放在一个文件中&#x3D;&#x3D;"></a>&#x3D;&#x3D;为什么模板的定义和声明要放在一个文件中&#x3D;&#x3D;</h3><blockquote><p><strong>在C++中，模板代码通常需要定义和声明一起放在同一个文件中，这是因为模板的编译和实例化过程需要具体的类型信息，而这些信息只有在编译器看到模板的定义时才能了解。</strong></p><p><strong>具体来说，当我们使用模板时，编译器需要知道模板的定义，以便为其生成实现代码。因此，模板代码的定义和声明需要在编译期可见。如果我们将模板的定义和声明分别放在不同的文件中，则只会在链接时发现错误，这会增加调试和维护的困难度。</strong></p><p><strong>另外，C标准库也是将模板代码的定义和声明放在同一个文件中的。这为其他开发人员提供了一个良好的参考标准，方便使用和维护C模板的代码。</strong></p><p><strong>因此，为了方便使用和维护C++模板代码，并且确保编译器能够正确生成和实例化模板，我们通常将模板的定义和声明放在同一个文件中。</strong></p></blockquote><hr><p><a href="https://www.zhihu.com/question/270627626?sort=created">C++为什么要求把类声明和类实现进行分离？又为什么要求模板类的类声明和类实现要都放在头文件而不能分离? - 知乎 (zhihu.com)</a> 好文看看！！</p><p>一般在写C++相关代码的时候，我们总习惯于将类声明和类实现进行分离。也就是说，类的声明一般写在.h文件中，而它的实现一般写在.cpp文件中。但是，在模板类中，这个习惯却要恰恰相反。即：要求模板类的类声明和类实现要都放在头文件，而不能分离。</p><p>本文就对模板的这个奇特习惯进行分析。</p><h3 id="分离式编译模式"><a href="#分离式编译模式" class="headerlink" title="分离式编译模式"></a>分离式编译模式</h3><p>在进行模板特性的讲解之前，首先需要了解一下C++的分离式编译模式。</p><p>所谓分离编译模式，就是指：一个程序或者项目由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件连接起来形成单一的可执行文件的过程。</p><p>C&#x2F;C++组织源代码和生成可执行文件的方式就是分离式编译模式。</p><p>简单粗暴的理解就是，一个C++项目分为若干个cpp文件和h文件，每个cpp文件单独编译成每个的目标文件，最终将每个cpp文件连接在一起组成最后的单一的可执行文件。这里最重要的点就是：编译是相对于每个cpp文件而言的。</p><p>接下去的问题就是，对于编译每个cpp文件的时候，是否都需要每个类的实现？</p><p>如果都需要每个类的实现，那么就只能将每个类的实现也都写到h文件中，这样在cpp文件中引入的h文件中，才会有每个类的实现；如果不需要每个类的实现，那么就没有必要将每个类的实现写到h文件中。</p><p>C&#x2F;C++所采用的方法是：只要给出类的声明，就可以在本源文件中使用该类。由于每个源文件都是独立的编译单元，在当前源文件中使用但未在此类的实现，就假设在其他的源文件中实现好了。</p><p>模板声明与定义<br>声明定义不分离<br>但是，分离式编译模式却驯不服模板。</p><p>C++标准要求编译器在实例化模板时，必须在上下文中可以查看到其实现；而反过来，在看到实例化模板之前，编译器对模板的实现是不处理的。原因很简单，编译器怎么会预先知道typename实参是什么呢？因此模板的实例化与实现必须放到同一文件中。</p><h3 id="《C-编程思想》说明了原因："><a href="#《C-编程思想》说明了原因：" class="headerlink" title="《C++编程思想》说明了原因："></a>《C++编程思想》说明了原因：</h3><p>模板定义很特殊。由template&lt;…&gt; 处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><p>简单来说：只有模板实例化时，编译器才会得知T实参是什么。而编译器在处理模板实例化时，不仅仅要看到模板的定义式，还需要模版的实现体。</p><h3 id="为什么需要这样呢？"><a href="#为什么需要这样呢？" class="headerlink" title="为什么需要这样呢？"></a>为什么需要这样呢？</h3><p>比如说存在类Rect, 其类定义式写在test.h，类的实现体写在test.cpp中。对于模板来说，编译器在处理test.cpp文件时，编译器无法预知T的实参是什么，所以编译器对其实现是不作处理的。</p><p>紧接着在main.cpp中用到了Rect，这个时候会实例化。也就是说，在test.h中会实例出对Rect进行类的声明。但是，由于分离式编译模式，在编译的时候只需要类的声明即可，因此编译是没有任何问题的。</p><p>但是在链接的过程中，需要找到Rect的实现部分。但是上面也说了，编译是相对于每个cpp文件而言的。在test.cpp的编译的时候，由于不知道T的实参是什么，并没有对其进行处理。因此，Rect的实现自然并没有被编译，链接也就自然而然地因找不到而出错。</p><p>也就是说，模板如果将类声明和类实现进行分离，那么分离式编译模式会导致在链接的时候出现问题。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>解释清楚了，接下来可以看一个例子：</p><p>在test.h文件中，定义模板类Rect：</p><pre><code class="c">#include &lt;iostream&gt;template&lt;typename T&gt;class Rect &#123;  public:    Rect(T l = 0.0f, T t = 0.0f, T r = 0.0f, T b = 0.0f) :      left_(l), top_(t), right_(r), bottom_(b) &#123;&#125;void display();T left_;T top_;T right_;T bottom_;&#125;;</code></pre><p>在test.cpp文件中，定义模板类Rect方法的实现：</p><pre><code class="c">#include &quot;test.h&quot;template&lt;typename T&gt;void Rect&lt;T&gt;::display() &#123;  std::cout &lt;&lt; left_ &lt;&lt; &quot; &quot; &lt;&lt; top_ &lt;&lt; &quot; &quot; &lt;&lt; right_    &lt;&lt; &quot; &quot; &lt;&lt; bottom_ &lt;&lt; std::endl;</code></pre><p>最终在main.cpp文件中，使用改模板类：</p><pre><code class="c">#include &lt;iostream&gt;#include &quot;test.h&quot;int main() &#123;  Rect&lt;float&gt; rect(1.1f, 2.2f, 3.3f, 4.4f);  rect.display();  return 0;&#125;</code></pre><blockquote><p>yngzmiao@yngzmiao-virtual-machine:~&#x2F;test&#x2F;build$ cmake .. &amp;&amp; make<br>– The C compiler identification is GNU 4.8.4<br>– The CXX compiler identification is GNU 4.8.4<br>– Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc<br>– Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc – works<br>– Detecting C compiler ABI info<br>– Detecting C compiler ABI info - done<br>– Detecting C compile features<br>– Detecting C compile features - done<br>– Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++<br>– Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++ – works<br>– Detecting CXX compiler ABI info<br>– Detecting CXX compiler ABI info - done<br>– Detecting CXX compile features<br>– Detecting CXX compile features - done<br>– Configuring done<br>– Generating done<br>– Build files have been written to: &#x2F;home&#x2F;yngzmiao&#x2F;test&#x2F;build<br>Scanning dependencies of target test<br>[ 25%] Building CXX object CMakeFiles&#x2F;test.dir&#x2F;test.cpp.o<br>[ 50%] Linking CXX static library libtest.a<br>[ 50%] Built target test<br>Scanning dependencies of target main<br>[ 75%] Building CXX object CMakeFiles&#x2F;main.dir&#x2F;main.cpp.o<br>[100%] Linking CXX executable main<br>CMakeFiles&#x2F;main.dir&#x2F;main.cpp.o：在函数‘main’中：<br>main.cpp:(.text+0x3c)：对‘Rect<float>::display()’未定义的引用<br>collect2: error: ld returned 1 exit status<br>make[2]: *** [main] 错误 1<br>make[1]: *** [CMakeFiles&#x2F;main.dir&#x2F;all] 错误 2<br>make: *** [all] 错误 2</p><p>可以看出，改代码在ld的过程中出现了错误，即链接的时候没有找到实现而出错。</p></blockquote><p>如果将模板类的声明和实现不分离，都写在.h文件中。即如下：</p><pre><code class="c">#include &lt;iostream&gt;template&lt;typename T&gt;class Rect &#123;  public:    Rect(T l = 0.0f, T t = 0.0f, T r = 0.0f, T b = 0.0f) :      left_(l), top_(t), right_(r), bottom_(b) &#123;&#125;void display() &#123;  std::cout &lt;&lt; left_ &lt;&lt; &quot; &quot; &lt;&lt; top_ &lt;&lt; &quot; &quot; &lt;&lt; right_    &lt;&lt; &quot; &quot; &lt;&lt; bottom_ &lt;&lt; std::endl;&#125;    T left_;    T top_;    T right_;    T bottom_;&#125;;</code></pre><p>最终编译运行没有问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在分离式编译的环境下，编译器编译某一个cpp文件时并不知道另一个cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于链接器）。</p><p>这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部链接的符号并期待链接器能够将符号的地址决议出来。</p><p>然而当实现该模板的cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程中就找不到一行模板实例的二进制代码，于是链接器也黔驴技穷了。</p><h2 id="为什么-c-中函数模板和类模板的-声明与定义需要放到一起？"><a href="#为什么-c-中函数模板和类模板的-声明与定义需要放到一起？" class="headerlink" title="为什么 c++中函数模板和类模板的 声明与定义需要放到一起？"></a><a href="https://www.cnblogs.com/zhangkele/p/7628141.html">为什么 c++中函数模板和类模板的 声明与定义需要放到一起？</a></h2><p>将模板的声明与定义写在一起实在很不优雅。尝试用“传统”方法，及在.h文件里声明,在.cpp文件里定义，</p><p>然后在main函数里包含.h头文件，这样会报链接错误。why！！！！！！！！！！！！！</p><p>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，（carefully！！！）</p><p>如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。（类模板同样！！）</p><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><pre><code> 1 //---------------test.h-------------------//  2  void f();//这里声明一个函数f  3 //---------------test.cpp--------------//  4  #include”test.h”  5  void f()  6  &#123;  7  …//do something  8  &#125; //这里实现出test.h中声明的f函数  9 //---------------main.cpp--------------// 10  #include”test.h” 11  int main() 12  &#123; 13      f(); //调用f14  &#125;</code></pre><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><p>编译时会生成两个obj文件，main.obj和test.obj，而在main.obj里并没有f函数的二进制代码，这些代码实际存在于test.obj中。</p><p><strong>在main.obj中对 f 的调用只会生成一行call指令，call指令的地址由链接器生成。</strong></p><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><pre><code> 1 //-------------test.h----------------//  2  template&lt;class T&gt;  3  class A  4  &#123;  5     public:  6      void f(); //这里只是个声明  7  &#125;;  8 //---------------test.cpp-------------//  9  #include”test.h” 10  template&lt;class T&gt; 11  void A&lt;T&gt;::f() 12  &#123; 13  …//do something 14  &#125; 15 //---------------main.cpp---------------// 16  #include”test.h” 17  int main() 18  &#123; 19      A&lt;int&gt; a; 20     a. f(); 21  &#125;</code></pre><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><p>我们知道<strong>模板有个具现化的过程，在未被使用的时候是不会生成二进制文件的。所以当链接器去找f函数的地址时，因为在这之前没有调用过f()，test.obj里自然就没有f函数的二进制代码，于是就会报错。</strong></p><h4 id="要使模板声明与定义分开也不是没有办法。"><a href="#要使模板声明与定义分开也不是没有办法。" class="headerlink" title="要使模板声明与定义分开也不是没有办法。"></a>要使模板声明与定义分开也不是没有办法。</h4><p><strong>第一种办法是在main函数里包含cpp文件</strong></p><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><pre><code> 1 //-------------test.h----------------//  2  template&lt;class T&gt;  3  class A  4  &#123;  5     public:  6      void f(); //这里只是个声明  7  &#125;;  8 //---------------test.cpp-------------//  9  #include”test.h” 10  template&lt;class T&gt; 11  void A&lt;T&gt;::f() 12  &#123; 13  …//do something 14  &#125; 15 //---------------main.cpp---------------// 16  #include”test.cpp” //careful！！！！！！！！！17  int main() 18  &#123; 19      A&lt;int&gt; a; 20     a. f(); 21  &#125;</code></pre><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><p>这样三个文件的内容通过include实际上包含在同一个文件里，自然就不会出错了</p><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><pre><code> 1 //-------------test.h----------------//  2  template&lt;class T&gt;  3  class A  4  &#123;  5     public:  6      void f(); //这里只是个声明  7  &#125;;  8 #include&lt;test_impl.h&gt; 9 //---------------test_impl.h-------------// 10  template&lt;class T&gt; 11  void A&lt;T&gt;::f() 12  &#123; 13  …//do something 14  &#125; 15 //---------------main.cpp---------------// 16  #include”test.h” 17  int main() 18  &#123; 19      A&lt;int&gt; a; 20     a. f(); 21  &#125;</code></pre><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><p><strong>这两种方法实际上都是包含编译，没有本质的区别，不过感觉第二种方法看起来比较舒服</strong></p><p><a href="javascript:void(0);">        <span class="lazyload-img-span">        <img              data-src="https://common.cnblogs.com/images/copycode.gif" >        </sapn>      </a></p><pre><code> 1 //-------------test.h----------------//  2  template&lt;class T&gt;  3  class A  4  &#123;  5     public:  6      void f(); //这里只是个声明  7  &#125;;  8 //---------------test.cpp-------------//  9  #include”test.h” 10  template&lt;class T&gt; 11  void A&lt;T&gt;::f() 12  &#123; 13  …//do something 14  &#125; 15 template class A&lt;int&gt;;//！！！！！！在这里实现了具现了类型  这样编译就不会有问题了  但是这样不太好  自己想为什么 ！！！16 //---------------main.cpp---------------// 17  #include”test.h” 18  int main() 19  &#123; 20      A&lt;int&gt; a; 21     a. f(); 22  &#125;</code></pre><p>第三种就需要自己在test.cpp指明实例化</p>]]></content>
      
      
      <categories>
          
          <category> Cpp进阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>net-snmp学习</title>
      <link href="/2023/05/22/net-snmp%E5%AD%A6%E4%B9%A01/"/>
      <url>/2023/05/22/net-snmp%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.net-snmp.org/wiki/index.php/TUT:Simple_Application">http://www.net-snmp.org/wiki/index.php/TUT:Simple_Application</a>  <strong>snmp官方文档</strong>**</p><h2 id="net-snmp学习笔记"><a href="#net-snmp学习笔记" class="headerlink" title="net-snmp学习笔记"></a>net-snmp学习笔记</h2><p><strong>程序开始需要声明几个变量：</strong><br>snmp_session，里面存储的是调用者与谁交互的信息，对标nta-&gt;三方。需要两个，一个用来填充信息，一个是库返回的指针<br>snmp_pdu 保存我们将要发送到远程主机的所有信息。他将为对方要发回的信息声明一秒钟<br>这俩都是struct结构体<br>oid类型  存oid  -》比如  oid  anOID [10]<br>variable_list 存储的是想要通过snmp操作的变量，也是结构体</p><p>接下来使用init_snmp初始化snmp 库，可以在调用的时候指定文件名，就会自动读取配置文件，默认&#x2F;etc下</p><p>初始化完成，用snmp_sess_init创建一个会话去和nms交互，可以用snmp_sess_init去设置一下会话的属性，就是前面snmp_session结构体</p><p>完事用snmp_open去打开会话，打开他之后会返回一个指针，这个指针就用开始定义的snmp_session指针去接收，指向我们应该使用的另一个会话</p><p>接下来，我们创建要发送到远程主机的 PDU ，当我们要求提供信息时。示例中这是snmpget程序使用的。它检索用于初始化它的每个 OID 的值。</p><p>因此，当我们用我们请求的 oid 填充它。让我们获取此示例的 system.sysDescr.0 变量。可以自己将数字无符号整数值放入我们上面创建的 anOID 数组中。或者用</p><pre><code>get_node(&quot;sysDescr.0&quot;, anOID, &amp;anOID_len); 拿到oid    read_objid(&quot;system.sysDescr.0&quot;, anOID, &amp;anOID_len); 解析   </code></pre><p>下来，我们使用snmp_add_null_var将此具有 NULL 值的 oid 添加到 PDU</p><p>最后，利用snmp_synch_response，我们可以使用会话指针和 pdu 发送请求，并返回状态和响应，该状态和响应存储在新定位错误的响应 pdu 指针中</p><p>最后snmp_sess_close关闭会话</p><p>用snmp_shutdown清理snmp库</p><h4 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo:"></a>示例demo:</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;net-snmp/net-snmp-config.h&gt;#include &lt;net-snmp/net-snmp-includes.h&gt;void print_variable(const oid *obj, const size_t obj_len, const netsnmp_variable_list *value)&#123;    int i;    char buf[1024];    switch(value-&gt;type) &#123;        case ASN_INTEGER:            printf(&quot;%s = %ld\n&quot;,snprint_objid(buf, sizeof(buf), obj, obj_len),*(value-&gt;val.integer));            break;        case ASN_OCTET_STR:            printf(&quot;%s = %.*s\n&quot;,snprint_objid(buf, sizeof(buf), obj, obj_len),value-&gt;val_len,value-&gt;val.string);            break;        default:            printf(&quot;%s = &quot;,snprint_objid(buf, sizeof(buf), obj, obj_len));            for(i=0;i&lt;value-&gt;val_len;i++) printf(&quot;%02X &quot;,value-&gt;val.string[i]);            printf(&quot;\n&quot;);            break;    &#125;&#125;int main(int argc, char ** argv) &#123;    struct snmp_session session, *snmp_sess_pointer;    struct snmp_pdu *pdu;    struct snmp_pdu *response;    oid anOID[MAX_OID_LEN];    size_t anOID_len;    netsnmp_variable_list *vars;    // 初始化SNMP库    init_snmp(&quot;snmp_app&quot;);    // 初始化会话    snmp_sess_init(&amp;session);    session.peername = argv[1]; // 指定SNMP代理程序的IP地址    session.version = SNMP_VERSION_2c; // 指定SNMP版本    session.community = &quot;public&quot;; // 指定社区字符串    session.community_len = strlen(session.community); // 计算社区字符串长度    // 开启SNMP会话    snmp_sess_pointer = snmp_sess_open(&amp;session);        if (!snmp_sess_pointer) &#123;        snmp_perror(&quot;snmp error&quot;);        snmp_log(LOG_ERR, &quot;something horrible happened!!!\n&quot;);        exit(1);    &#125;    // 准备发送PDU    pdu = snmp_pdu_create(SNMP_MSG_GET); // 创建一个GET请求的PDU    anOID_len = MAX_OID_LEN;    if (read_objid(&quot;IF-MIB::ifInOctets.1&quot;, anOID, &amp;anOID_len)) &#123; // 解析OID字符串        snmp_perror(&quot;read_objid error&quot;);        exit(1);    &#125;    snmp_add_null_var(pdu, anOID, anOID_len); // 向PDU添加待查询的OID    // 发送SNMP请求并获取响应    if (snmp_synch_response(snmp_sess_pointer, pdu, &amp;response) == STAT_SUCCESS) &#123;        // 打印接收到的响应结果        for (vars = response-&gt;variables; vars; vars = vars-&gt;next_variable) &#123;            print_variable(vars-&gt;name, vars-&gt;name_length, vars);        &#125;    &#125; else &#123;        snmp_perror(&quot;snmp error&quot;);    &#125;    // 关闭SNMP会话    snmp_sess_close(snmp_sess_pointer);    // 清理SNMP库    snmp_shutdown(&quot;snmp_app&quot;);    return 0;&#125;</code></pre><ol><li>初始化SNMP库：调用<code>init_snmp()</code>函数初始化SNMP库（在程序中，传入<code>&quot;snmp_app&quot;</code>作为库名）。</li><li>初始化会话：调用<code>snmp_sess_init()</code>函数初始化SNMP会话。</li><li>开启SNMP会话：调用<code>snmp_sess_open()</code>函数建立到SNMP代理程序的连接，并返回一个指向SNMP会话的指针，若返回NULL则连接失败。</li><li>准备发送PDU：使用<code>snmp_pdu_create()</code>函数创建一个待发送的PDU（本示例中创建的是一个SNMP GET请求的PDU），然后使用<code>read_objid()</code>函数解析OID字符串，并调用<code>snmp_add_null_var()</code>函数向PDU添加待查询的OID。</li><li>发送SNMP请求并获取响应：使用<code>snmp_synch_response()</code>函数向SNMP代理程序发送请求，并获取响应。</li><li>打印接收到的响应结果：使用<code>print_variable()</code>函数打印接收到的SNMP变量值。</li><li>关闭SNMP会话：调用<code>snmp_sess_close()</code>函数关闭到SNMP代理程序的连接。</li><li>清理SNMP库：调用<code>snmp_shutdown()</code>函数清理SNMP库，释放相关资源。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>520🫦</title>
      <link href="/2023/05/19/520/"/>
      <url>/2023/05/19/520/</url>
      
        <content type="html"><![CDATA[<h2 id="我们的第一个520🥰"><a href="#我们的第一个520🥰" class="headerlink" title="我们的第一个520🥰"></a><font color=DeepPink>我们的第一个520</font>🥰</h2><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519012327(1).jpg" >        </sapn>      </p><p>感觉五一之后才分开了两周，但是每天晚上都很想你。你五一走的时候我是第一次感受到什么叫揪心，真的很难受，莫名的无力感，心里空荡荡的，完事之后那几天就很没劲，感觉五一也没带你好好玩，🫥害。后面才缓过来</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013110(1).jpg" >        </sapn>      </p><p>这周刚开始你说我们要吵架我感觉，怎么可能呢？？？完事跟我室友取了取经，总结必不可能！谁知？？…也怪我那晚回你消息慢了宝儿，我当时微信在电脑上登着呢，所以手机半天也没提示😿完事你发的消息我看了之后，♥直接凉一半，心想完蛋了，就一直在反思自己，也不敢烦你… </p><p><font color=Tomato>还好还好，我家宝贝善解人意，美丽大方，无比温柔，心地善良，原谅了我这个笨比。希望我们以后越来越好！        <span class="lazyload-img-span">        <img              data-src="/../images/520/640" >        </sapn>      </font></p><p>非常非常非常幸运，我正在谈着一段无敌爆炸nice的恋爱，感觉和你谈恋爱有让我在一直变好，我总是能在你身上得到我需要的情绪价值！！我们拖着累的要死的身子，可还是一直走着去了猫咖，一路上一直在笑，我感觉那一天可能是我笑得最多的那一次..</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013352(1).jpg" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013349(1).jpg" >        </sapn>      </p><p>我们看着同一个落日，今天又是多爱了你的一天🌇</p><p>我的计划是一直记录生活，很庆幸我也被你所记录着。在这立个flag，在今年过年前或者毕业前一定和你去海边🌊，我们一起踩👣沙子，看螃蟹🦀，看日出🌅，日落🌇，环海路骑车兜风🪧，拍照，拍视频..地点由你定，maybe威海，平潭小岛，南澳岛，海南等等..</p><p>最后的最后今年520的礼物🎁，我非常喜欢~~氛围极好，音响也不戳🎲</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013359(1).jpg" >        </sapn>      </p><h5 id="对了，宝贝你的520礼物，再等等哦-明天睡起来就能收到🎉"><a href="#对了，宝贝你的520礼物，再等等哦-明天睡起来就能收到🎉" class="headerlink" title="对了，宝贝你的520礼物，再等等哦~  明天睡起来就能收到🎉"></a>对了，宝贝你的520礼物，再等等哦~  明天睡起来就能收到🎉</h5>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么C++要比Java和Python快🤕</title>
      <link href="/2023/05/19/C++-Java-Pyhon/"/>
      <url>/2023/05/19/C++-Java-Pyhon/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么C-要比Java和Python快？？🤪"><a href="#为什么C-要比Java和Python快？？🤪" class="headerlink" title="为什么C++要比Java和Python快？？🤪"></a><font face="STCAIYUN">为什么C++要比Java和Python快？？</font>🤪</h2><ul><li><font color=VioletRed>有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（比如 Windows 下的 .exe 文件），比如C语言、<a href="http://c.biancheng.net/cplus/">C++</a>、Golang、<a href="http://c.biancheng.net/asm/">汇编语言</a>等，它们都属于<strong>编译型语言</strong>，使用的转换工具称为<strong>编译器</strong>。</font></li><li><font color=pink>有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 <a href="http://c.biancheng.net/python/">Python</a>、<a href="http://c.biancheng.net/js/">JavaScript</a>、<a href="http://c.biancheng.net/php/">PHP</a>、Shell 等，这类编程语言称为<strong>解释型语言</strong>，使用的转换工具称为<strong>解释器</strong>。</font></li></ul><h2 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h2><p>对于编译型语言，开发完成以后需要将所有的源代码都转换成可执行程序，比如 Windows 下的<code>.exe</code>文件就是一个可执行程序，它里面包含的就是机器码，只要拥有这个可执行程序，就可以随时运行，不需要再重新编译，也就是“一次编译，无限次运行”。</p><p>在运行的时候，我们只需要编译生成的可执行程序，此时就不再需要源代码和编译器，所以编译型语言可以脱离开发环境运行。</p><p>编译型语言通常是不能跨平台的，也就是不能在不同的操作系统之间随意切换。</p><p>编译型语言不能跨平台表现在两个方面：</p><h4 id="1-可执行程序不能跨平台"><a href="#1-可执行程序不能跨平台" class="headerlink" title="1) 可执行程序不能跨平台"></a>1) 可执行程序不能跨平台</h4><p>可执行程序不能跨平台很容易理解，因为不同操作系统对可执行文件的内部结构有着截然不同的要求，彼此之间也不能兼容。不能跨平台是天经地义，能跨平台反而才是奇葩。</p><p>比如，你不能将 Windows 下的可执行程序拿到 Linux 下使用，也不能将 Linux 下的可执行程序拿到 macOS 下使用（虽然它们都是<a href="http://c.biancheng.net/view/vip_5038.html">类 Unix 系统</a>）。</p><p>注意：相同操作系统的不同版本之间也不一定兼容，比如不能将 x64 程序（Windows 64 位程序）拿到 x86 平台上（Windows 32 位平台）运行。但反之一般可行，因为 64 位 Windows 对 32 位程序做了很好的兼容性处理。</p><h4 id="2-源代码不能跨平台"><a href="#2-源代码不能跨平台" class="headerlink" title="2) 源代码不能跨平台"></a>2) 源代码不能跨平台</h4><p>不同平台支持的函数、类型、变量等都可能不同，基于某个平台编写的源代码一般不能拿到另一个平台直接运行。下面以C语言为例进行说明。</p><p>【实例1】在C语言中，要想让程序暂停，我们可以使用“睡眠”函数。在 Windows 平台下该函数是 Sleep() ，并以毫秒为时间单位，而在 Linux 平台下则是 sleep()， 以秒为单位。可以看出，首先两个函数的首字母大小写不同，再者 Sleep() 的参数是毫秒，而 sleep() 的参数是秒，单位也不一样。</p><p>以上两个原因导致具有暂停功能的C语言程序不能跨平台，除非在代码层面对平台的兼容性做出处理，但这非常麻烦。</p><p>【实例2】虽然不同平台的C语言都支持 long 类型，但不同平台下 long 类型所占用的字节长度却不相同。例如 Windows 64 位平台下的 long 占用 4 个字节，Linux 64 位平台下的 long 却占用 8 个字节。</p><p>如果在 Linux 64 位平台下编写代码时，将 8 字节的值赋值给 long 类型的变量，这是完全没有问题的，但如果是在 Windows 平台下就会导致数值溢出，让程序产生错误的运行结果。</p><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>对于解释型语言，每次执行程序都需要一边转换一边执行，用到哪些源代码就将哪些源代码转换成机器码，用不到的则不进行任何处理。</p><p>由于每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至是数量级的差距。因此计算机的一些底层功能，或者关键算法，一般都使用 C&#x2F;C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。</p><p>在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。</p><p>例如，当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：</p><ul><li>对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是闭源的；</li><li>对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是开源的。</li></ul><p>相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真实存在的，而且比比皆是。那么，为什么解释型语言就能跨平台呢？</p><p>其实，这一切都要归功于解释器！</p><p>这里所说的跨平台，是指源代码跨平台，而非解释器跨平台。解释器用来将源代码转换成机器码，它本质上就是一个可执行程序，是绝对不能跨平台的。</p><p>说白了编译型语言在编译之后拿着.exe文件，不管在哪都能跑，不用配置环境什么的，，而解释型就不行了，要运行就得配置环境（python解释器，，java解释器，虚拟机）</p><h2 id="C-编译流程"><a href="#C-编译流程" class="headerlink" title="C++ 编译流程"></a>C++ 编译流程</h2><p>C++ 程序在编写完成或者做了更改后的第一次运行前，需要先编译。C++ 编译的整个过程分为 4 步：</p><p>注意在汇编前的程序都是文本，经过汇编，就转换为了二进制文件，C++ 中常说的机器码就是二进制，二进制文件就可以直接交由计算机运行了。接下来详细讲一下四个步骤中发生了什么：</p><ol><li><strong>预处理</strong><br>在预处理阶段，比如我们现在写了一个 main.cpp 文件进行预处理。预处理器会将头文件导入当前的代码，比如 iostream 或 string 等头文件。<br>之后会将注释给删除，将代码中的宏替换为宏的定义。<br>预处理直接对源文件进行处理，并不关注语法规则等，处理后的文件为 main.i。</li><li><strong>编译</strong><br>在编译阶段，编译器会检查代码的语法是否正确，并且可以对代码进行优化（O1，O2 优化等），之后将 main.i 文件转换为汇编语言程序 main.s，汇编语言是一种相对底层的语言，它为各种不同的高级语言提供了统一的输出（JAVA，C&#x2F;C++ 等）</li><li><strong>汇编</strong><br>在汇编阶段，汇编器将 main.s 汇编语言文件转换为机器语言指令（也就是常说的二进制机器码），并将文件转换为 main.o。这时候如果用文本打开该文件，会得到一堆乱码，这是因为文本编辑器通常使用 UTF-8 的 ASCII 码进行编解码，而这些二进制文件是不适用的。</li><li><strong>链接</strong><br>在链接阶段，链接器会将上述的 main.o 文件与库文件（后缀为 .a 或者 .lib）链接为一个应用程序，我们可以在执行链接时指定需要使用的库。<br>链接分为静态链接和动态链接，静态链接就是简单地将所需要链接的库的内容全部加入目标可执行程序中。静态链接的问题在于在一个计算机中如果存在多个相同程序，那么这些程序都会拷贝这个静态库，相当于内存中会存在多份静态库的拷贝，相当占用内存！另外，静态库对程序的更新会带来麻烦，如果静态库更新了，所有使用它的应用程序都需要重新编译再发布给用户。<br>而与之相对的是动态链接，动态链接不会讲库拷贝到程序中，而是在应用程序中添加所调用库的描述信息（一般是库函数的重定位信息），执行的时候就会根据库的重定位信息调用库函数。所以动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库更新时带来的麻烦。用户只需在运行程序时更新动态库即可。</li><li>应用程序包含的是机器码，也就是二进制数据，这些二进制指令是可以直接交由计算机操作的，是一种最底层语言，因此效率很高。而且多次执行相同的程序，只有第一次需要编译。</li></ol><h2 id="Python-代码执行流程"><a href="#Python-代码执行流程" class="headerlink" title="Python 代码执行流程"></a>Python 代码执行流程</h2><p>Python 之所以被称为脚本语言，是因为其不需要在运行前编译，而是在运行过程中“像脚本一样”被解释器逐句转换为机器码（二进制），这样的话相当于每次执行 Python 脚本，都要再进行一次转换为二进制的过程，因此在这一点上 Python 就已经慢了很多。</p><h2 id="C-与-Python-效率比较"><a href="#C-与-Python-效率比较" class="headerlink" title="C++ 与 Python 效率比较"></a>C++ 与 Python 效率比较</h2><p>言归正传，所以这两种语言的效率差异到底体现在什么地方呢？</p><p>首先第一点就是上文提到的，每次执行 Python 脚本，都要再由解释器进行一次转换为二进制的过程，而 C++ 只有第一次需要编译，后续都可以直接执行机器码。</p><p>这里我们可以举一个例子：</p><p>编写 Python 脚本时不需要声明类型，而是交由解释器进行动态类型检查。Python 官方指定的解释器为 CPython，CPython 是基于 C 实现的，在 CPython 中，每个对象底层都是一个 Obj* 指针类型，这个指针可以指向任意一种类型，所以所以它可以指向任意的对象，因此Python无法做基于类型方面的优化。以变量a + b为例，这个a和b指向的对象可以是整型、浮点型、字符串、列表、元组、甚至是我们自己实现了某个方法的类的实例对象。在计算 a+b 时，首先 Python 要判断变量到底指向的是什么类型，这在 C 级至少需要一次属性查找。然后 Python 将每一个操作都抽象成了一个方法，所以实例相加时要在对应的类型对象中找到该方法对应的函数指针，这又是一次属性查找。找到了之后将a、b作为参数传递进去，这会发生一次函数调用，会将 a 和 b 中维护的值拿出来进行运算，然后根据相加结果创建一个新的对象，再返回其对应的 PyObject * 指针。而对于 C++ 来讲，由于已经规定好了类型，所以a + b在编译之后就是一条简单的机器指令，所以两者在效率上差别很大。</p><p>第二点是 C++ 在编译阶段是可以进行优化的，C++ 编译器通常默认是 O0 优化，这是使用了最快的编译时间，在这种优化模式下：</p><p>所有变量都存在内存中，只有运算结果会放在 CPU 的寄存器上，所以会有较多的内存读写操作。<br>禁用其他的优化，会尽可能按照用户代码生成指令。<br>O1 优化：</p><p>循环变量通过寄存器计算，不再写入内存（比如 for (int i &#x3D; 0; i &lt; 10; ++i) 中的 i）<br>之后还有 O2 和 O3 优化，但是因为这些优化比较激进，会大幅增加编译的时间，而且编译后的文件难以调试，一般比较少用到。</p><p><strong>总之，C++ 中存在编译过程的优化，而 Python 并没有，这又在另一个维度上让 C++ 快于 Python。</strong></p><h2 id="Java语言是编译型语言还是解释型语言？"><a href="#Java语言是编译型语言还是解释型语言？" class="headerlink" title="Java语言是编译型语言还是解释型语言？"></a>Java语言是编译型语言还是解释型语言？</h2><p>我们都知道，编程语言从程序执行过程分，分为编译型语言和解释性语言</p><p>什么是编译型语言和解释型语言？</p><p>Java语言看似是编译型的，因为Java程序代码的确是需要经过编译的<br>还记得在cmd中用javac的命令吗？<br>没错，javac就是用来编译Java程序代码的（把.java源程序编译为.class文件）<br>不经过编译，.java文件运行不了!</p><p>Java语言又看似是解释型的，因为Java程序要在JVM上解释运行</p><p>那到底Java是什么类型的语言呢？</p><h4 id="x3D-x3D-Java是解释型语言-x3D-x3D"><a href="#x3D-x3D-Java是解释型语言-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java是解释型语言&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java是解释型语言&#x3D;&#x3D;</h4><p><strong>为什么Java是解释型语言？</strong><br>Java首先由编译器编译成.class类型的文件，这个是java自己类型的文件 然后在通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，正是由于java在JVM（虚拟机）上解释运行，对于多种不同的操作系统有不同的JVM，所以 Java才实现了真正意义上的跨平台！</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C++-Java-Pyhon/20190622154643762.png" >        </sapn>      </p><p>再来几张图帮助理解Java的解释执行过程：</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C++-Java-Pyhon/20190622154706401.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C++-Java-Pyhon/20190622154747801.png" >        </sapn>      </p><p><strong><font color=#008000>通过以上介绍，我们对Java程序执行过程就清楚了</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器🍞</title>
      <link href="/2023/05/17/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2023/05/17/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="锅巴py🤑"><a href="#锅巴py🤑" class="headerlink" title="锅巴py🤑"></a>锅巴py🤑</h1><h2 id="Python小白杀猪刀，装饰器"><a href="#Python小白杀猪刀，装饰器" class="headerlink" title="Python小白杀猪刀，装饰器"></a><font color=Peach>Python小白杀猪刀，装饰器</font></h2><p><strong>装饰器</strong>的作用就是为已经存在的对象添加额外的功能，你肯定听着很懵逼，下面从例子带你了解他的原理</p><p><strong>go~~</strong></p><h3 id="plus1"><a href="#plus1" class="headerlink" title="plus1:"></a>plus1:</h3><p>现在有如下函数，我们需要将这个函数的日志打印到终端</p><pre><code class="python">def add(x,y):    print(&#39; 我被调用执行啦 &#39;)  # 新增打印日志语句    return x + yadd(100,200)# 输出 我被调用执行啦</code></pre><p>但是仔细思考，打印日志是一个独立的功能，它和 add 函数本身并没有什么关联关系，我们说一个函数是为完成一个工程的，所以直接写在函数里面不是不可以，但是不建议，并且打印日志属于调试信息功能，与业务无关，不应该放在业务函数加法中。<br>  如果不需要写在函数的里面，那么我们得想办法写在函数的外面。</p><pre><code class="python">def add(x, y):    return x + ydef logger(fn, x, y):    print(&#39; 函数开始执行 &#39;)    res = fn(x, y)    print(&#39; 函数执行完毕 &#39;)    return reslogger(add,4,5)</code></pre><ul><li>这样就解决了打印语句在函数内定义的问题了。</li><li>但是如果 add 函数的形参很多，我们要挨个写上吗？所以 * args,**kwargs 帮了我们很大的忙</li></ul><pre><code class="python">def add(x, y):    return x + ydef logger(fn, *args, **kwargs):    print(&#39; 函数开始执行 &#39;)    res = fn(*args, **kwargs)    print(&#39; 函数执行完毕 &#39;)    return reslogger(add,4,5)</code></pre><hr><h3 id="plus2"><a href="#plus2" class="headerlink" title="plus2:"></a>plus2:</h3><p>有个专业术语叫做<strong>柯里化</strong>（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。（来自维基百科）</p><p>总结一下：柯里化指的就是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。其数学表达式为：</p><pre><code class="python">z = f(x, y) # 转换成 z = f(x)(y) # 的形式</code></pre><p>这里把经典的 add 函数拿来进行转换：</p><p>想要转换为 add(4)(5)，那么 add(4) 必须要返回一个函数，否则无法将 5 当作参数传入</p><pre><code class="python">def add(x, y):    return x + ydef new_add(x):    def inner(y):        return x + y    return innerprint(add(4, 5))     # 9print(new_add(4)(5)) # 9print(add(4, 5) == new_add(4)(5))  # True</code></pre><p>其实就是一个函数套函数的技巧。</p><hr><h3 id="plus3"><a href="#plus3" class="headerlink" title="plus3:"></a>plus3:</h3><p>对于最开始案例的函数调用给外人看太丑了吧，因此python引入了柯里化这种思想，我们去改进一下上面的add,logger案例，让他变的更美观，更优雅</p><p>结合plus2的柯里化去改进plus1</p><pre><code class="python">def add(x,y):    return x+ydef logger(fn):    def wrapper(*args,**kwargs):        print(&quot;函数被执行了&quot;)        res=fn(*args,**kwargs)        print(&quot;函数执行完毕&quot;)        return res    return wrapperlogger(add)(4,5)   #-&gt;fn接收add函数名，(4,5)是add参数，被wrapper(*args,**kwargs)接收 #其实wrapper函数就成了add函数</code></pre><p>​这样看起来是不是就好看多了？当指定 logger(add)(4,5) 时，才会打印日志，但如果想要在所有调用 add 函数的地方，我们还需要在所有调用 add 的地方修改为 logger(add)(参数), 想一想，<strong>如果我能把 logger(add) 变成 add 是不是就可以直接写成 add(4,5) 了呢？</strong><br>​其实上面的调用形式就等于如下：</p><pre><code class="python">logger(add)(4,5)--------add = logger(add)add(4,5)    # 将 add 重新指向了新的函数 wrapper</code></pre><p>​按照柯里化的原型中 logger(add) 返回了一个函数 wrapper，而我们的(4,5) 其实是传递给了 wrapper，结合我们前面所学的高阶函数，这里的 wrapper，是一个闭包函数，因为在内部对 fn 进行了执行，这个fn接收的就是add函数名，调的就是add函数，我们在执行 wrapper 的同时，也会执行原来的函数 fn(add)，并且wrapper添加了打印日志的功能</p><p>这样形式的logger 函数就是一个装饰器函数！！！装饰了add函数</p><hr><p>当然看很多公司代码或者框架源码的时候都不会这么复杂的调用，他会利用到语法糖@去简化调用书写，<strong>一个@修饰符就是一个函数【格式：*@修饰名*】</strong>，它将被修饰的函数作为参数，并返回修饰后的同名函数或其他可调用的东西（如果返回不是一个可调用的对象那么会报错）</p><p>注意注意，python里面的变量名，变量名！看上面的例子return wrapper，就是返回了这个函数名，所以需要我们后面自己去调用，，有的人查资料看到说@语法糖会自己直接执行调用，纯属扯淡，自己调是因为他装饰器函数最后返回了一个函数调用(),而且是没参数的那种函数，，当然你直接带实参也是可以的，，不过推荐就返回函数名，下民自己调，自己把握时机</p><p><strong>举三个代码例子就行：</strong></p><p>无参的，返回函数调用：</p><pre><code class="python">def logger(fn):    def wrapper():        print(&quot;函数被执行了&quot;)        res=fn()        print(&quot;函数执行完毕&quot;)        return res    return wrapper()  #注意这里 @logger            #不用我们去调用，自动调用返回了def add():    print(&quot;add&quot;)</code></pre><p>返回函数名：</p><pre><code class="python">def logger(fn):    def wrapper():        print(&quot;函数被执行了&quot;)        res=fn()        print(&quot;函数执行完毕&quot;)        return res    return wrapper  #注意这里 @loggerdef add():    print(&quot;add&quot;)        add()#自己调用一下</code></pre><p>带参的返回函数调用：需要我们自己去指定实参</p><pre><code class="python">def logger(fn):    def wrapper(x,y):        print(&quot;函数被执行了&quot;)        res=fn(x,y)        print(&quot;函数执行完毕&quot;)        return res    return wrapper(2,5)  #注意这里 @loggerdef add(x,y):    print(&quot;add&quot;)    print(x+y)    return x+y</code></pre><p>看到这应该就对@+装饰器有了基础了解了吧~~~</p><p>下面接着上面logger例子深入讲装饰器+@，改成如下样子：</p><pre><code class="python">def logger(fn):    def wrapper(*args, **kwargs):        print(&#39; 函数被执行了 &#39;)        res = fn(*args, **kwargs)        print(&#39; 函数执行完毕 &#39;)        return res    return wrapper# 等于 add = logger(add)，，@标识logger是一个装饰器，python解释器会自己去找logger函数@loggerdef add(x, y):    return x + yadd(4,5)#直接这么调用，就可以</code></pre><blockquote><p>​     <strong>当解释器执行到<code>@logger</code>时，会自动把它下面的函数当作参数，传给 logger 函数，所以这里<code>@logger</code>其实就等于<code>add = logger(add)</code> 另外，logger 必须要定义在 add 函数之前才可以被装载！这一点很重要！</strong></p></blockquote><hr><h3 id="下面说一下对于使用装饰器可以做的一些改进或者问题？？"><a href="#下面说一下对于使用装饰器可以做的一些改进或者问题？？" class="headerlink" title="下面说一下对于使用装饰器可以做的一些改进或者问题？？"></a>下面说一下对于使用装饰器可以做的一些改进或者问题？？</h3><p>利用装饰器计算如下函数的运行时间</p><pre><code class="python">import timeimport datetimedef logger(fn):    def wrapper(*args, **kwargs):        start = datetime.datetime.now()        res = fn(*args, **kwargs)        duration = (datetime.datetime.now() - start).total_seconds()        print(&#39; 函数：&#123;&#125; 执行用时：&#123;&#125;&#39;.format(wrapper.__name__, duration))        return res                    #这里__name__ 表示当前函数的名称.    return wrapper@loggerdef add(x, y):    time.sleep(2)    return x + y# 执行结果：In: add(4,5)函数：wrapper 执行用时：2.000944</code></pre><ul><li><p><input disabled="" type="checkbox"> 什么鬼？这里为什么打印的是 wrapper 啊，为什么不是 add 呢？这样的话，别人不就发现我把这个函数给偷偷换掉了吗？不行不行，我得想个办法把函数的属性复制过来，由于这个功能和打印用时的装饰器不是一个功能，那么我们还得给装饰器再加一个装饰器。-_-!</p><pre><code class="python">import timeimport datetimedef copy_properties(old_fn):    def wrapper(new_fn):        new_fn.__name__ = old_fn.__name__        return new_fn    return wrapperdef logger(fn):    @copy_properties(fn)  # wrapper = copy_properties(fn)(wrapper)    def wrapper(*args, **kwargs):        start = datetime.datetime.now()        res = fn(*args, **kwargs)        total_seconds = (datetime.datetime.now() - start).total_seconds()        print(&#39; 函数：&#123;&#125; 执行用时：&#123;&#125;&#39;.format(wrapper.__name__,total_seconds))        return res    return wrapper@loggerdef add(x, y):    time.sleep(2)    return x + yadd(4,5)</code></pre></li></ul><ol><li>解释器执行到<code>@copy_properties(fn)</code>时，会把下面的 wraper 装入，等于<code>wrapper = copy_properties(fn)(wrapper)</code></li><li>add就会跳到&#96;@copy_properties，用add的名字old_fn.__name__赋值给new_fn.__name__，返回这个新名字，后面拿到的就是这个被替换的名字（狸猫换太子了属于是）</li><li>由于知道了参数的个数(一定是一个函数对象)，这里就没有使用 * args, **kwargs</li><li>函数的属性不止<code>__name__</code>一个，其他的怎么办呢？</li></ol><hr><p>当然要我们在封装一个装饰器未免太麻烦了，以简便著称的python贴心的为我们提供了拷贝函数属性的内置函数</p><h3 id="拷贝函数属性"><a href="#拷贝函数属性" class="headerlink" title="拷贝函数属性"></a>拷贝函数属性</h3><p>  Python 的内置模块 functools 中，内置了很多常用的高阶函数，其中 wraps 就是用来拷贝函数的属性及签名信息的。利用 wraps，我们就不需要自己编写 copy_properties 函数了，下面是修改后的版本：</p><pre><code class="python">import timeimport datetimeimport functoolsdef logger(fn):    @functools.wraps(fn)  # wrapper = functools.wraps(fn)(wrapper)    def wrapper(*args, **kwargs):        start = datetime.datetime.now()        res = fn(*args, **kwargs)        total_seconds = (datetime.datetime.now() - start).total_seconds()        print(&#39; 函数：&#123;&#125; 执行用时：&#123;&#125;&#39;.format(wrapper.__name__,total_seconds))        return res    return wrapper@loggerdef add(x, y):    time.sleep(2)    return x + yadd(4,5)</code></pre><ul><li><input disabled="" type="checkbox"> 通过使用<code>@functools.wraps(fn)</code> 我们可以方便的拷贝函数的属性签名信息，比如：<code>__module__</code>、<code>__name__</code>、<code>__qualname__</code>、<code>__doc__</code>、<code>__annotations__</code> 等，这些属性信息，将在后续部分进行讲解，这里知道即可</li></ul><hr><p>上面演示的都是带一个参数的装饰器，Python称这种装饰器为无参装饰器，因为语法糖的表现形式就是 <code>@logger</code>, 下面要说的是带参数的装饰器，即 <code>@logger(args)</code></p><p>以上述函数为例，我们需要记录当函数执行超过一定时间时的日志信息，该怎么办呢？假设这个时间是 5 秒，那么很显然，我们需要把这个时间变量传入到装饰器中进行判断。也就是说我们需要写成这种形式：</p><pre><code class="python">logger(5)(add)(4,5)</code></pre><blockquote><p>logger（5）返回一个函数，，其实是函数名，，之后这个函数名再(add)，等于把add当参数传进去，后面跟着add的参数（4,5），</p></blockquote><pre><code class="python">import timeimport datetimeimport functoolsdef logger(var):# logger的参数    def inner(func): #接收add        def wrapper(*args, **kwargs):            start = datetime.datetime.now()            res = func(*args, **kwargs)            total_seconds = (datetime.datetime.now() - start).total_seconds()            if total_seconds &gt; var:                print(&#39; 函数执行时间过长 &#39;)            return res        return wrapper    return inner@logger(5)  # logger(5)(add)(4,5)def add(x, y):    time.sleep(6)    return x + yadd(4,5)#等于不要@语法糖这么去调用，logger(5)(add)(4,5)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World🖥️</title>
      <link href="/2023/05/15/hello-world/"/>
      <url>/2023/05/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora Modify the color🎃</title>
      <link href="/2023/05/15/typora%20color1/"/>
      <url>/2023/05/15/typora%20color1/</url>
      
        <content type="html"><![CDATA[<p>分享一个自己常用的Emoji表情网站:✨<a href="https://emojixd.com/">🤣 Emoji表情大全，颜文字百科 💌 - EmojiXD</a></p><p>推荐阅读:<a href="https://blog.csdn.net/Treasure99/article/details/105601866"> Markdown文字颜色、高亮、字体字号设置_markdown文字高亮语法_</a></p><h2 id="用Typora时改变字体颜色，自己常用的方式"><a href="#用Typora时改变字体颜色，自己常用的方式" class="headerlink" title="用Typora时改变字体颜色，自己常用的方式"></a>用Typora时改变字体颜色，自己常用的方式</h2><p>&#x3D;&#x3D;代码：用的就是html的语法格式&#x3D;&#x3D;</p><pre><code class="html">&lt;font color=&#39;orange&#39;&gt;并发&lt;/font&gt;</code></pre><p><font color='orange'>并发</font><br>需要什么颜色和字体直接改就可以了，下面给大家一些个人感觉还不错的颜色，并不是单词名字就和显示的一样，大家用了才能看到</p><p>Apricot ：杏色，显示的是红色比红色要淡</p><p>Peach : 桃色，但显示出来是翠绿色</p><p>each ：刚刚删掉Peach想测试小写是否可以（是可以的），而看到这个竟然也有颜色，还挺好看</p><p>Bittersweet ：苦乐参半色，嘻嘻</p><p>RedOrange ：红色</p><p>BrickRed ：比苦乐参半色要浅</p><p>Salmon ：橙色的感觉</p><p>Magenta ：粉紫的感觉</p><p>VioletRed ：深粉的感觉</p><p>Rhodamine ：龙井绿茶的感觉</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>520🫦</title>
      <link href="/2023/05/19/520/"/>
      <url>/2023/05/19/520/</url>
      
        <content type="html"><![CDATA[<h2 id="我们的第一个520🥰"><a href="#我们的第一个520🥰" class="headerlink" title="我们的第一个520🥰"></a><font color=DeepPink>我们的第一个520</font>🥰</h2><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519012327(1).jpg" >        </sapn>      </p><p>感觉五一之后才分开了两周，但是每天晚上都很想你。你五一走的时候我是第一次感受到什么叫揪心，真的很难受，莫名的无力感，心里空荡荡的，完事之后那几天就很没劲，感觉五一也没带你好好玩，🫥害。后面才缓过来</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013110(1).jpg" >        </sapn>      </p><p>这周刚开始你说我们要吵架我感觉，怎么可能呢？？？完事跟我室友取了取经，总结必不可能！谁知？？…也怪我那晚回你消息慢了宝儿，我当时微信在电脑上登着呢，所以手机半天也没提示😿完事你发的消息我看了之后，♥直接凉一半，心想完蛋了，就一直在反思自己，也不敢烦你… </p><p><font color=Tomato>还好还好，我家宝贝善解人意，美丽大方，无比温柔，心地善良，原谅了我这个笨比。希望我们以后越来越好！        <span class="lazyload-img-span">        <img              data-src="/../images/520/640" >        </sapn>      </font></p><p>非常非常非常幸运，我正在谈着一段无敌爆炸nice的恋爱，感觉和你谈恋爱有让我在一直变好，我总是能在你身上得到我需要的情绪价值！！我们拖着累的要死的身子，可还是一直走着去了猫咖，一路上一直在笑，我感觉那一天可能是我笑得最多的那一次..</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013352(1).jpg" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013349(1).jpg" >        </sapn>      </p><p>我们看着同一个落日，今天又是多爱了你的一天🌇</p><p>我的计划是一直记录生活，很庆幸我也被你所记录着。在这立个flag，在今年过年前或者毕业前一定和你去海边🌊，我们一起踩👣沙子，看螃蟹🦀，看日出🌅，日落🌇，环海路骑车兜风🪧，拍照，拍视频..地点由你定，maybe威海，平潭小岛，南澳岛，海南等等..</p><p>最后的最后今年520的礼物🎁，我非常喜欢~~氛围极好，音响也不戳🎲</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/520/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230519013359(1).jpg" >        </sapn>      </p><h5 id="对了，宝贝你的520礼物，再等等哦-明天睡起来就能收到🎉"><a href="#对了，宝贝你的520礼物，再等等哦-明天睡起来就能收到🎉" class="headerlink" title="对了，宝贝你的520礼物，再等等哦~  明天睡起来就能收到🎉"></a>对了，宝贝你的520礼物，再等等哦~  明天睡起来就能收到🎉</h5>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么C++要比Java和Python快🤕</title>
      <link href="/2023/05/19/C++-Java-Pyhon/"/>
      <url>/2023/05/19/C++-Java-Pyhon/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么C-要比Java和Python快？？🤪"><a href="#为什么C-要比Java和Python快？？🤪" class="headerlink" title="为什么C++要比Java和Python快？？🤪"></a><font face="STCAIYUN">为什么C++要比Java和Python快？？</font>🤪</h2><ul><li><font color=VioletRed>有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（比如 Windows 下的 .exe 文件），比如C语言、<a href="http://c.biancheng.net/cplus/">C++</a>、Golang、<a href="http://c.biancheng.net/asm/">汇编语言</a>等，它们都属于<strong>编译型语言</strong>，使用的转换工具称为<strong>编译器</strong>。</font></li><li><font color=pink>有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 <a href="http://c.biancheng.net/python/">Python</a>、<a href="http://c.biancheng.net/js/">JavaScript</a>、<a href="http://c.biancheng.net/php/">PHP</a>、Shell 等，这类编程语言称为<strong>解释型语言</strong>，使用的转换工具称为<strong>解释器</strong>。</font></li></ul><h2 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h2><p>对于编译型语言，开发完成以后需要将所有的源代码都转换成可执行程序，比如 Windows 下的<code>.exe</code>文件就是一个可执行程序，它里面包含的就是机器码，只要拥有这个可执行程序，就可以随时运行，不需要再重新编译，也就是“一次编译，无限次运行”。</p><p>在运行的时候，我们只需要编译生成的可执行程序，此时就不再需要源代码和编译器，所以编译型语言可以脱离开发环境运行。</p><p>编译型语言通常是不能跨平台的，也就是不能在不同的操作系统之间随意切换。</p><p>编译型语言不能跨平台表现在两个方面：</p><h4 id="1-可执行程序不能跨平台"><a href="#1-可执行程序不能跨平台" class="headerlink" title="1) 可执行程序不能跨平台"></a>1) 可执行程序不能跨平台</h4><p>可执行程序不能跨平台很容易理解，因为不同操作系统对可执行文件的内部结构有着截然不同的要求，彼此之间也不能兼容。不能跨平台是天经地义，能跨平台反而才是奇葩。</p><p>比如，你不能将 Windows 下的可执行程序拿到 Linux 下使用，也不能将 Linux 下的可执行程序拿到 macOS 下使用（虽然它们都是<a href="http://c.biancheng.net/view/vip_5038.html">类 Unix 系统</a>）。</p><p>注意：相同操作系统的不同版本之间也不一定兼容，比如不能将 x64 程序（Windows 64 位程序）拿到 x86 平台上（Windows 32 位平台）运行。但反之一般可行，因为 64 位 Windows 对 32 位程序做了很好的兼容性处理。</p><h4 id="2-源代码不能跨平台"><a href="#2-源代码不能跨平台" class="headerlink" title="2) 源代码不能跨平台"></a>2) 源代码不能跨平台</h4><p>不同平台支持的函数、类型、变量等都可能不同，基于某个平台编写的源代码一般不能拿到另一个平台直接运行。下面以C语言为例进行说明。</p><p>【实例1】在C语言中，要想让程序暂停，我们可以使用“睡眠”函数。在 Windows 平台下该函数是 Sleep() ，并以毫秒为时间单位，而在 Linux 平台下则是 sleep()， 以秒为单位。可以看出，首先两个函数的首字母大小写不同，再者 Sleep() 的参数是毫秒，而 sleep() 的参数是秒，单位也不一样。</p><p>以上两个原因导致具有暂停功能的C语言程序不能跨平台，除非在代码层面对平台的兼容性做出处理，但这非常麻烦。</p><p>【实例2】虽然不同平台的C语言都支持 long 类型，但不同平台下 long 类型所占用的字节长度却不相同。例如 Windows 64 位平台下的 long 占用 4 个字节，Linux 64 位平台下的 long 却占用 8 个字节。</p><p>如果在 Linux 64 位平台下编写代码时，将 8 字节的值赋值给 long 类型的变量，这是完全没有问题的，但如果是在 Windows 平台下就会导致数值溢出，让程序产生错误的运行结果。</p><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>对于解释型语言，每次执行程序都需要一边转换一边执行，用到哪些源代码就将哪些源代码转换成机器码，用不到的则不进行任何处理。</p><p>由于每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至是数量级的差距。因此计算机的一些底层功能，或者关键算法，一般都使用 C&#x2F;C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。</p><p>在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。</p><p>例如，当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：</p><ul><li>对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是闭源的；</li><li>对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是开源的。</li></ul><p>相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真实存在的，而且比比皆是。那么，为什么解释型语言就能跨平台呢？</p><p>其实，这一切都要归功于解释器！</p><p>这里所说的跨平台，是指源代码跨平台，而非解释器跨平台。解释器用来将源代码转换成机器码，它本质上就是一个可执行程序，是绝对不能跨平台的。</p><p>说白了编译型语言在编译之后拿着.exe文件，不管在哪都能跑，不用配置环境什么的，，而解释型就不行了，要运行就得配置环境（python解释器，，java解释器，虚拟机）</p><h2 id="C-编译流程"><a href="#C-编译流程" class="headerlink" title="C++ 编译流程"></a>C++ 编译流程</h2><p>C++ 程序在编写完成或者做了更改后的第一次运行前，需要先编译。C++ 编译的整个过程分为 4 步：</p><p>注意在汇编前的程序都是文本，经过汇编，就转换为了二进制文件，C++ 中常说的机器码就是二进制，二进制文件就可以直接交由计算机运行了。接下来详细讲一下四个步骤中发生了什么：</p><ol><li><strong>预处理</strong><br>在预处理阶段，比如我们现在写了一个 main.cpp 文件进行预处理。预处理器会将头文件导入当前的代码，比如 iostream 或 string 等头文件。<br>之后会将注释给删除，将代码中的宏替换为宏的定义。<br>预处理直接对源文件进行处理，并不关注语法规则等，处理后的文件为 main.i。</li><li><strong>编译</strong><br>在编译阶段，编译器会检查代码的语法是否正确，并且可以对代码进行优化（O1，O2 优化等），之后将 main.i 文件转换为汇编语言程序 main.s，汇编语言是一种相对底层的语言，它为各种不同的高级语言提供了统一的输出（JAVA，C&#x2F;C++ 等）</li><li><strong>汇编</strong><br>在汇编阶段，汇编器将 main.s 汇编语言文件转换为机器语言指令（也就是常说的二进制机器码），并将文件转换为 main.o。这时候如果用文本打开该文件，会得到一堆乱码，这是因为文本编辑器通常使用 UTF-8 的 ASCII 码进行编解码，而这些二进制文件是不适用的。</li><li><strong>链接</strong><br>在链接阶段，链接器会将上述的 main.o 文件与库文件（后缀为 .a 或者 .lib）链接为一个应用程序，我们可以在执行链接时指定需要使用的库。<br>链接分为静态链接和动态链接，静态链接就是简单地将所需要链接的库的内容全部加入目标可执行程序中。静态链接的问题在于在一个计算机中如果存在多个相同程序，那么这些程序都会拷贝这个静态库，相当于内存中会存在多份静态库的拷贝，相当占用内存！另外，静态库对程序的更新会带来麻烦，如果静态库更新了，所有使用它的应用程序都需要重新编译再发布给用户。<br>而与之相对的是动态链接，动态链接不会讲库拷贝到程序中，而是在应用程序中添加所调用库的描述信息（一般是库函数的重定位信息），执行的时候就会根据库的重定位信息调用库函数。所以动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库更新时带来的麻烦。用户只需在运行程序时更新动态库即可。</li><li>应用程序包含的是机器码，也就是二进制数据，这些二进制指令是可以直接交由计算机操作的，是一种最底层语言，因此效率很高。而且多次执行相同的程序，只有第一次需要编译。</li></ol><h2 id="Python-代码执行流程"><a href="#Python-代码执行流程" class="headerlink" title="Python 代码执行流程"></a>Python 代码执行流程</h2><p>Python 之所以被称为脚本语言，是因为其不需要在运行前编译，而是在运行过程中“像脚本一样”被解释器逐句转换为机器码（二进制），这样的话相当于每次执行 Python 脚本，都要再进行一次转换为二进制的过程，因此在这一点上 Python 就已经慢了很多。</p><h2 id="C-与-Python-效率比较"><a href="#C-与-Python-效率比较" class="headerlink" title="C++ 与 Python 效率比较"></a>C++ 与 Python 效率比较</h2><p>言归正传，所以这两种语言的效率差异到底体现在什么地方呢？</p><p>首先第一点就是上文提到的，每次执行 Python 脚本，都要再由解释器进行一次转换为二进制的过程，而 C++ 只有第一次需要编译，后续都可以直接执行机器码。</p><p>这里我们可以举一个例子：</p><p>编写 Python 脚本时不需要声明类型，而是交由解释器进行动态类型检查。Python 官方指定的解释器为 CPython，CPython 是基于 C 实现的，在 CPython 中，每个对象底层都是一个 Obj* 指针类型，这个指针可以指向任意一种类型，所以所以它可以指向任意的对象，因此Python无法做基于类型方面的优化。以变量a + b为例，这个a和b指向的对象可以是整型、浮点型、字符串、列表、元组、甚至是我们自己实现了某个方法的类的实例对象。在计算 a+b 时，首先 Python 要判断变量到底指向的是什么类型，这在 C 级至少需要一次属性查找。然后 Python 将每一个操作都抽象成了一个方法，所以实例相加时要在对应的类型对象中找到该方法对应的函数指针，这又是一次属性查找。找到了之后将a、b作为参数传递进去，这会发生一次函数调用，会将 a 和 b 中维护的值拿出来进行运算，然后根据相加结果创建一个新的对象，再返回其对应的 PyObject * 指针。而对于 C++ 来讲，由于已经规定好了类型，所以a + b在编译之后就是一条简单的机器指令，所以两者在效率上差别很大。</p><p>第二点是 C++ 在编译阶段是可以进行优化的，C++ 编译器通常默认是 O0 优化，这是使用了最快的编译时间，在这种优化模式下：</p><p>所有变量都存在内存中，只有运算结果会放在 CPU 的寄存器上，所以会有较多的内存读写操作。<br>禁用其他的优化，会尽可能按照用户代码生成指令。<br>O1 优化：</p><p>循环变量通过寄存器计算，不再写入内存（比如 for (int i &#x3D; 0; i &lt; 10; ++i) 中的 i）<br>之后还有 O2 和 O3 优化，但是因为这些优化比较激进，会大幅增加编译的时间，而且编译后的文件难以调试，一般比较少用到。</p><p><strong>总之，C++ 中存在编译过程的优化，而 Python 并没有，这又在另一个维度上让 C++ 快于 Python。</strong></p><h2 id="Java语言是编译型语言还是解释型语言？"><a href="#Java语言是编译型语言还是解释型语言？" class="headerlink" title="Java语言是编译型语言还是解释型语言？"></a>Java语言是编译型语言还是解释型语言？</h2><p>我们都知道，编程语言从程序执行过程分，分为编译型语言和解释性语言</p><p>什么是编译型语言和解释型语言？</p><p>Java语言看似是编译型的，因为Java程序代码的确是需要经过编译的<br>还记得在cmd中用javac的命令吗？<br>没错，javac就是用来编译Java程序代码的（把.java源程序编译为.class文件）<br>不经过编译，.java文件运行不了!</p><p>Java语言又看似是解释型的，因为Java程序要在JVM上解释运行</p><p>那到底Java是什么类型的语言呢？</p><h4 id="x3D-x3D-Java是解释型语言-x3D-x3D"><a href="#x3D-x3D-Java是解释型语言-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java是解释型语言&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java是解释型语言&#x3D;&#x3D;</h4><p><strong>为什么Java是解释型语言？</strong><br>Java首先由编译器编译成.class类型的文件，这个是java自己类型的文件 然后在通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，正是由于java在JVM（虚拟机）上解释运行，对于多种不同的操作系统有不同的JVM，所以 Java才实现了真正意义上的跨平台！</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C++-Java-Pyhon/20190622154643762.png" >        </sapn>      </p><p>再来几张图帮助理解Java的解释执行过程：</p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C++-Java-Pyhon/20190622154706401.png" >        </sapn>      </p><p>        <span class="lazyload-img-span">        <img              data-src="/../images/C++-Java-Pyhon/20190622154747801.png" >        </sapn>      </p><p><strong><font color=#008000>通过以上介绍，我们对Java程序执行过程就清楚了</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器🍞</title>
      <link href="/2023/05/17/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2023/05/17/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="锅巴py🤑"><a href="#锅巴py🤑" class="headerlink" title="锅巴py🤑"></a>锅巴py🤑</h1><h2 id="Python小白杀猪刀，装饰器"><a href="#Python小白杀猪刀，装饰器" class="headerlink" title="Python小白杀猪刀，装饰器"></a><font color=Peach>Python小白杀猪刀，装饰器</font></h2><p><strong>装饰器</strong>的作用就是为已经存在的对象添加额外的功能，你肯定听着很懵逼，下面从例子带你了解他的原理</p><p><strong>go~~</strong></p><h3 id="plus1"><a href="#plus1" class="headerlink" title="plus1:"></a>plus1:</h3><p>现在有如下函数，我们需要将这个函数的日志打印到终端</p><pre><code class="python">def add(x,y):    print(&#39; 我被调用执行啦 &#39;)  # 新增打印日志语句    return x + yadd(100,200)# 输出 我被调用执行啦</code></pre><p>但是仔细思考，打印日志是一个独立的功能，它和 add 函数本身并没有什么关联关系，我们说一个函数是为完成一个工程的，所以直接写在函数里面不是不可以，但是不建议，并且打印日志属于调试信息功能，与业务无关，不应该放在业务函数加法中。<br>  如果不需要写在函数的里面，那么我们得想办法写在函数的外面。</p><pre><code class="python">def add(x, y):    return x + ydef logger(fn, x, y):    print(&#39; 函数开始执行 &#39;)    res = fn(x, y)    print(&#39; 函数执行完毕 &#39;)    return reslogger(add,4,5)</code></pre><ul><li>这样就解决了打印语句在函数内定义的问题了。</li><li>但是如果 add 函数的形参很多，我们要挨个写上吗？所以 * args,**kwargs 帮了我们很大的忙</li></ul><pre><code class="python">def add(x, y):    return x + ydef logger(fn, *args, **kwargs):    print(&#39; 函数开始执行 &#39;)    res = fn(*args, **kwargs)    print(&#39; 函数执行完毕 &#39;)    return reslogger(add,4,5)</code></pre><hr><h3 id="plus2"><a href="#plus2" class="headerlink" title="plus2:"></a>plus2:</h3><p>有个专业术语叫做<strong>柯里化</strong>（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。（来自维基百科）</p><p>总结一下：柯里化指的就是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。其数学表达式为：</p><pre><code class="python">z = f(x, y) # 转换成 z = f(x)(y) # 的形式</code></pre><p>这里把经典的 add 函数拿来进行转换：</p><p>想要转换为 add(4)(5)，那么 add(4) 必须要返回一个函数，否则无法将 5 当作参数传入</p><pre><code class="python">def add(x, y):    return x + ydef new_add(x):    def inner(y):        return x + y    return innerprint(add(4, 5))     # 9print(new_add(4)(5)) # 9print(add(4, 5) == new_add(4)(5))  # True</code></pre><p>其实就是一个函数套函数的技巧。</p><hr><h3 id="plus3"><a href="#plus3" class="headerlink" title="plus3:"></a>plus3:</h3><p>对于最开始案例的函数调用给外人看太丑了吧，因此python引入了柯里化这种思想，我们去改进一下上面的add,logger案例，让他变的更美观，更优雅</p><p>结合plus2的柯里化去改进plus1</p><pre><code class="python">def add(x,y):    return x+ydef logger(fn):    def wrapper(*args,**kwargs):        print(&quot;函数被执行了&quot;)        res=fn(*args,**kwargs)        print(&quot;函数执行完毕&quot;)        return res    return wrapperlogger(add)(4,5)   #-&gt;fn接收add函数名，(4,5)是add参数，被wrapper(*args,**kwargs)接收 #其实wrapper函数就成了add函数</code></pre><p>​这样看起来是不是就好看多了？当指定 logger(add)(4,5) 时，才会打印日志，但如果想要在所有调用 add 函数的地方，我们还需要在所有调用 add 的地方修改为 logger(add)(参数), 想一想，<strong>如果我能把 logger(add) 变成 add 是不是就可以直接写成 add(4,5) 了呢？</strong><br>​其实上面的调用形式就等于如下：</p><pre><code class="python">logger(add)(4,5)--------add = logger(add)add(4,5)    # 将 add 重新指向了新的函数 wrapper</code></pre><p>​按照柯里化的原型中 logger(add) 返回了一个函数 wrapper，而我们的(4,5) 其实是传递给了 wrapper，结合我们前面所学的高阶函数，这里的 wrapper，是一个闭包函数，因为在内部对 fn 进行了执行，这个fn接收的就是add函数名，调的就是add函数，我们在执行 wrapper 的同时，也会执行原来的函数 fn(add)，并且wrapper添加了打印日志的功能</p><p>这样形式的logger 函数就是一个装饰器函数！！！装饰了add函数</p><hr><p>当然看很多公司代码或者框架源码的时候都不会这么复杂的调用，他会利用到语法糖@去简化调用书写，<strong>一个@修饰符就是一个函数【格式：*@修饰名*】</strong>，它将被修饰的函数作为参数，并返回修饰后的同名函数或其他可调用的东西（如果返回不是一个可调用的对象那么会报错）</p><p>注意注意，python里面的变量名，变量名！看上面的例子return wrapper，就是返回了这个函数名，所以需要我们后面自己去调用，，有的人查资料看到说@语法糖会自己直接执行调用，纯属扯淡，自己调是因为他装饰器函数最后返回了一个函数调用(),而且是没参数的那种函数，，当然你直接带实参也是可以的，，不过推荐就返回函数名，下民自己调，自己把握时机</p><p><strong>举三个代码例子就行：</strong></p><p>无参的，返回函数调用：</p><pre><code class="python">def logger(fn):    def wrapper():        print(&quot;函数被执行了&quot;)        res=fn()        print(&quot;函数执行完毕&quot;)        return res    return wrapper()  #注意这里 @logger            #不用我们去调用，自动调用返回了def add():    print(&quot;add&quot;)</code></pre><p>返回函数名：</p><pre><code class="python">def logger(fn):    def wrapper():        print(&quot;函数被执行了&quot;)        res=fn()        print(&quot;函数执行完毕&quot;)        return res    return wrapper  #注意这里 @loggerdef add():    print(&quot;add&quot;)        add()#自己调用一下</code></pre><p>带参的返回函数调用：需要我们自己去指定实参</p><pre><code class="python">def logger(fn):    def wrapper(x,y):        print(&quot;函数被执行了&quot;)        res=fn(x,y)        print(&quot;函数执行完毕&quot;)        return res    return wrapper(2,5)  #注意这里 @loggerdef add(x,y):    print(&quot;add&quot;)    print(x+y)    return x+y</code></pre><p>看到这应该就对@+装饰器有了基础了解了吧~~~</p><p>下面接着上面logger例子深入讲装饰器+@，改成如下样子：</p><pre><code class="python">def logger(fn):    def wrapper(*args, **kwargs):        print(&#39; 函数被执行了 &#39;)        res = fn(*args, **kwargs)        print(&#39; 函数执行完毕 &#39;)        return res    return wrapper# 等于 add = logger(add)，，@标识logger是一个装饰器，python解释器会自己去找logger函数@loggerdef add(x, y):    return x + yadd(4,5)#直接这么调用，就可以</code></pre><blockquote><p>​     <strong>当解释器执行到<code>@logger</code>时，会自动把它下面的函数当作参数，传给 logger 函数，所以这里<code>@logger</code>其实就等于<code>add = logger(add)</code> 另外，logger 必须要定义在 add 函数之前才可以被装载！这一点很重要！</strong></p></blockquote><hr><h3 id="下面说一下对于使用装饰器可以做的一些改进或者问题？？"><a href="#下面说一下对于使用装饰器可以做的一些改进或者问题？？" class="headerlink" title="下面说一下对于使用装饰器可以做的一些改进或者问题？？"></a>下面说一下对于使用装饰器可以做的一些改进或者问题？？</h3><p>利用装饰器计算如下函数的运行时间</p><pre><code class="python">import timeimport datetimedef logger(fn):    def wrapper(*args, **kwargs):        start = datetime.datetime.now()        res = fn(*args, **kwargs)        duration = (datetime.datetime.now() - start).total_seconds()        print(&#39; 函数：&#123;&#125; 执行用时：&#123;&#125;&#39;.format(wrapper.__name__, duration))        return res                    #这里__name__ 表示当前函数的名称.    return wrapper@loggerdef add(x, y):    time.sleep(2)    return x + y# 执行结果：In: add(4,5)函数：wrapper 执行用时：2.000944</code></pre><ul><li><p><input disabled="" type="checkbox"> 什么鬼？这里为什么打印的是 wrapper 啊，为什么不是 add 呢？这样的话，别人不就发现我把这个函数给偷偷换掉了吗？不行不行，我得想个办法把函数的属性复制过来，由于这个功能和打印用时的装饰器不是一个功能，那么我们还得给装饰器再加一个装饰器。-_-!</p><pre><code class="python">import timeimport datetimedef copy_properties(old_fn):    def wrapper(new_fn):        new_fn.__name__ = old_fn.__name__        return new_fn    return wrapperdef logger(fn):    @copy_properties(fn)  # wrapper = copy_properties(fn)(wrapper)    def wrapper(*args, **kwargs):        start = datetime.datetime.now()        res = fn(*args, **kwargs)        total_seconds = (datetime.datetime.now() - start).total_seconds()        print(&#39; 函数：&#123;&#125; 执行用时：&#123;&#125;&#39;.format(wrapper.__name__,total_seconds))        return res    return wrapper@loggerdef add(x, y):    time.sleep(2)    return x + yadd(4,5)</code></pre></li></ul><ol><li>解释器执行到<code>@copy_properties(fn)</code>时，会把下面的 wraper 装入，等于<code>wrapper = copy_properties(fn)(wrapper)</code></li><li>add就会跳到&#96;@copy_properties，用add的名字old_fn.__name__赋值给new_fn.__name__，返回这个新名字，后面拿到的就是这个被替换的名字（狸猫换太子了属于是）</li><li>由于知道了参数的个数(一定是一个函数对象)，这里就没有使用 * args, **kwargs</li><li>函数的属性不止<code>__name__</code>一个，其他的怎么办呢？</li></ol><hr><p>当然要我们在封装一个装饰器未免太麻烦了，以简便著称的python贴心的为我们提供了拷贝函数属性的内置函数</p><h3 id="拷贝函数属性"><a href="#拷贝函数属性" class="headerlink" title="拷贝函数属性"></a>拷贝函数属性</h3><p>  Python 的内置模块 functools 中，内置了很多常用的高阶函数，其中 wraps 就是用来拷贝函数的属性及签名信息的。利用 wraps，我们就不需要自己编写 copy_properties 函数了，下面是修改后的版本：</p><pre><code class="python">import timeimport datetimeimport functoolsdef logger(fn):    @functools.wraps(fn)  # wrapper = functools.wraps(fn)(wrapper)    def wrapper(*args, **kwargs):        start = datetime.datetime.now()        res = fn(*args, **kwargs)        total_seconds = (datetime.datetime.now() - start).total_seconds()        print(&#39; 函数：&#123;&#125; 执行用时：&#123;&#125;&#39;.format(wrapper.__name__,total_seconds))        return res    return wrapper@loggerdef add(x, y):    time.sleep(2)    return x + yadd(4,5)</code></pre><ul><li><input disabled="" type="checkbox"> 通过使用<code>@functools.wraps(fn)</code> 我们可以方便的拷贝函数的属性签名信息，比如：<code>__module__</code>、<code>__name__</code>、<code>__qualname__</code>、<code>__doc__</code>、<code>__annotations__</code> 等，这些属性信息，将在后续部分进行讲解，这里知道即可</li></ul><hr><p>上面演示的都是带一个参数的装饰器，Python称这种装饰器为无参装饰器，因为语法糖的表现形式就是 <code>@logger</code>, 下面要说的是带参数的装饰器，即 <code>@logger(args)</code></p><p>以上述函数为例，我们需要记录当函数执行超过一定时间时的日志信息，该怎么办呢？假设这个时间是 5 秒，那么很显然，我们需要把这个时间变量传入到装饰器中进行判断。也就是说我们需要写成这种形式：</p><pre><code class="python">logger(5)(add)(4,5)</code></pre><blockquote><p>logger（5）返回一个函数，，其实是函数名，，之后这个函数名再(add)，等于把add当参数传进去，后面跟着add的参数（4,5），</p></blockquote><pre><code class="python">import timeimport datetimeimport functoolsdef logger(var):# logger的参数    def inner(func): #接收add        def wrapper(*args, **kwargs):            start = datetime.datetime.now()            res = func(*args, **kwargs)            total_seconds = (datetime.datetime.now() - start).total_seconds()            if total_seconds &gt; var:                print(&#39; 函数执行时间过长 &#39;)            return res        return wrapper    return inner@logger(5)  # logger(5)(add)(4,5)def add(x, y):    time.sleep(6)    return x + yadd(4,5)#等于不要@语法糖这么去调用，logger(5)(add)(4,5)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora Modify the color🎃</title>
      <link href="/2023/05/15/typora%20color1/"/>
      <url>/2023/05/15/typora%20color1/</url>
      
        <content type="html"><![CDATA[<p>分享一个自己常用的Emoji表情网站:✨<a href="https://emojixd.com/">🤣 Emoji表情大全，颜文字百科 💌 - EmojiXD</a></p><p>![image-20230518212617569](..&#x2F;images&#x2F;typora color1&#x2F;image-20230518212617569.png)</p><p>推荐阅读:<a href="https://blog.csdn.net/Treasure99/article/details/105601866"> Markdown文字颜色、高亮、字体字号设置_markdown文字高亮语法_</a></p><h2 id="用Typora时改变字体颜色，自己常用的方式"><a href="#用Typora时改变字体颜色，自己常用的方式" class="headerlink" title="用Typora时改变字体颜色，自己常用的方式"></a>用Typora时改变字体颜色，自己常用的方式</h2><p>&#x3D;&#x3D;代码：用的就是html的语法格式&#x3D;&#x3D;</p><pre><code class="html">&lt;font color=&#39;orange&#39;&gt;并发&lt;/font&gt;</code></pre><p><font color='orange'>并发</font><br>需要什么颜色和字体直接改就可以了，下面给大家一些个人感觉还不错的颜色，并不是单词名字就和显示的一样，大家用了才能看到</p><p>Apricot ：杏色，显示的是红色比红色要淡</p><p>Peach : 桃色，但显示出来是翠绿色</p><p>each ：刚刚删掉Peach想测试小写是否可以（是可以的），而看到这个竟然也有颜色，还挺好看</p><p>Bittersweet ：苦乐参半色，嘻嘻</p><p>RedOrange ：红色</p><p>BrickRed ：比苦乐参半色要浅</p><p>Salmon ：橙色的感觉</p><p>Magenta ：粉紫的感觉</p><p>VioletRed ：深粉的感觉</p><p>Rhodamine ：龙井绿茶的感觉</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World🖥️</title>
      <link href="/2023/05/15/hello-world/"/>
      <url>/2023/05/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
